-----------------------------------------------第一天------------------------------------------------------------
一,项目介绍
1,博客管理系统
2,前台页面
  主要用于数据展示,给用户浏览,里面的数据应该是动态从后台获取,进行动态渲染的;
  给用户去看的
3,后台页面
  对数据进行管理,进行增删改查
  给管理员的
4,项目开发流程
  人员配比:产品经理 => UI 设计师 => 项目经理/技术总监 => 前端/后端 =>测试人员
  需求设计: 负责人 产品经理
      1) 为什么做这个项目,什么样的市场需求,盈利如何
      2) 根据客户的需求来定
      3)项目营销点
  原型设计:给项目打草稿,画出原型图   负责人 产品经理
  UI设计:将产品原型图,转换成PSD设计图   负责人 UI设计师
  技术选型:确定用什么技术进行开发   负责人  项目经理/技术总监
          1)前端:   html html5 css2 css3 jquery vue.js... 
          2)后台:   php  java python go...  
          3)数据库 mysql oracle SQL server
          考虑因素:成本问题 团队技术实力
  数据库设计:主要是对数据表的设计   负责人  DBA数据库管理员(或者后台)
  项目架构设计:负责人 项目经理 架构师 技术总监 
    1)项目的架构设计
    2)文件的组织结构
    3)代码的组织结构
  业务开发迭代开发: 负责人  具体开发工程师,测试人员
     1)开发迭代一个过程
     2)开发 ->测试 ->开发 ->测试....
  集中测试:专门的测试人员来完成;先进行内测;再进行公测   专门负责测试的
  项目上线:将醒目部署到服务器上
二,功能实现
1,批量修改文件后缀名
    新建bat文件:
    eg:   rename.bat;  这是一个脚本/批处理程序
    在文件内写: rename *.html *.php;
                windows内双击执行即可; 
                rename 是固定语法:修改名字的意思,注意空格;
2,用户登录基本完成
    1)利用表单提交  action method name 
    2)将action=''会将表单提交给当前页面,如果有$_POST就进行登录校验
    empty($_POST)是不是空?非空就进行校验:空的就直接访问页面;
    不写action也是默认提交到当前页面;
    3)邮箱和密码要求非空,如果是空的就要提示用户
    4)根据用户输入的用户名和密码去数据库查询该用户的信息,
    按照用户名与表单内的名字比对查询:
    eg:     select * from users where 字段名='获取的用户名';
    如果没有查到用户名,提示:用户名不存在
    如果查到了用户名,进行校验;校验成功,跳转到首页;校验失败,输出错误信息
3,会话保持
    1)会话保持,保持登录状态;session_start();将用户的user id 数据存在session中,来标记用户;
    2)登录拦截,判断该登录的用户的cookie是否有sessionid?如果没有直接拦截到登录页;
    如果有就尝试获取userid,如果有userid允许访问;如果没有就拦截到登录页  
4,退出
    1,在用户端的退出,用户可以自己清空浏览器缓存,相当于删掉了cookie,没有sessionid携带了;
    2,在服务器端的退出,在服务器端销毁session文件;
公共模块的路径是相对于引入的文件来进行计算的
三,首页
1,动态显示当前用户昵称和头像;
  从session中获取用户id;
  编写sql语句,查询数据库,从数据库中取出用户信息;
  渲染;
2,侧边栏高亮
  给每个页面添加页面标识
  让一级导航高亮,给大li添加active类
  让二级菜单高亮,只要是在子菜单中,就让二级菜单高亮,in_array(a,arr);
  二级菜单高亮,需要展开,给ul加上in类;
  二级菜单高亮,箭头需要向下,给a标签移除collapsed类
  小li高亮,
-----------------------------------------------第二天------------------------------------------------------------
一,反馈知识点
isset?empty?使用   false,[],'',0这些对empty是空;isset就是设置了;
二,仪表盘数据查询
1,需求 动态显示文章,草稿等数量
2,思路 :1)编写sql语句
          文章总数;草稿总数;.....
          select count(*) as 变量名 from 表名 where 条件
        2)查询数据库 
        3)进行页面渲染
三,评论页面
1,页面基本渲染
  1)准备后台接口,到数据库中查询评论数据
  2)要求分页;联合查询post的标题输出;limit 起始索引,条数;
  3)将php单独写成一个接口,集合管理;前端传入页数,每页多少条;
      执行sql,将结果转成json字符串返回给前端
知识点:
1,字符串的方法substr(开始,截取个数)
2,分页插件使用步骤,依赖于jQuery;详细,请看方法介绍
        1)引包,link ; jQ; pagination;
        2)准备DOM结构,一个div盒子
        3)初始化,通过数据总条数进行初始化,默认每页10条数据;
          书写结构: div.pagination(总条数,{可选参数用对象的方式传入})
        可选参数详解:    prev_text:'上一页',
                        next_text:'下一页',
                        items_per_page:10,//每页显示的条数
                        num_edge_entries:2,//两侧首尾的条目数
                        num_display_entries:5,//分页中间的连续主体条目数
                        current_page:0,//当前索引,0开始为第一页
                        link_to:'aa?id=123',//页面跳转
                        callback:funciton(index){},//index对象是当前(点击时)执行这个函数的当前页面的索引
                        load_first_page:true/false,//一进入页面,是否调用回调函数?
3,通过模板动态生成的结构,一开始页面中没有,不能直接绑定事件;
给存在的父级元素绑定事件,由子元素触发事件即可(事件委托)
事件委托优点:1)可以给动态生成的结构绑定点击事件;
            2)因为事件是给父辈元素绑定的,所以事件只要绑定一次,所有子元素都可以触发事件,效率较高;
4,删除的时候,需要返回剩余的总条数给前端;
需要重新渲染分页标签;
如果在最后一页删除最后一条,会导致最大页数减小,当前页应该等于最大页;
var maxpage = Math.ceil(接口函数返回的页数l/10);
if(当前页>maxpage){
  当前页 = maxpage;
}
-----------------------------------------------第三天------------------------------------------------------------
1,对象的.和[];
对象.属性名;点语法时后面不会解析属性名;
对象['属性名'];[]内要传字符串,如果不是字符串,会去找这个变量,如果是字符串就去找对应的属性名;[]会解析变量,.不会;
2,prop和attr
    prop('属性名',true/false)  一般用于checked,disabled,selected;
    attr('属性名',属性值)   一般用去除了上面的其他的;
3,在盒子的行内样式中,class="pull-right",相当于加了右浮动的类
4,sql语句中in语法,可以进行操作多个或者单个的操作; 
5,查询文章的时候,最好使用联合查询,获取有效的文章显示出来;
6,textarea富文本编辑器
  wangEditor富文本编辑器
  步骤:
      (1)引包
      (2)准备容器
      (3)进行初始化(基本的)
      实例化对象:
        var 变量名 = new wangEditor();
        变量名.create();
  1)设置内容,可以直接在html结构中设置内容进行初始化;
    也可以通过js实现设置内容,可以识别标签
    变量名.txt.html('设置的内容')
  2)追加
   变量名.txt.append('追加的内容')
  3)清空内容
    变量名.txt.clear()
  4)获取内容html/text 
   获取html:  变量名.txt.html()   获取的是带标签的
   获取txt :  变量名.txt.text()   获取的是纯文本的
  5)同步到textarea中,用于表单提交;wangEditor不是表单元素,不能提交
  变量名.customconfig.onchange =function(html){
    //这里的html就是富文本编辑器的内容;html只是形参,可以写任何名字
    //默认是带标签格式的,用户再次编辑的时候,格式字体都在;
  }
  //注意,注册这个监听事件,需要注册在创建实例对象之前;
7,input事件    别名同步
    在表单元素内容发生变化的时候触发
    结构: 元素.oninput = 函数体;注册on事件
8,图片实时预览
  1)异步文件上传;有兼容问题;每张图片都会存在服务器中;
  2)URL 对象 
    URL.createObjectURL(文件对象)  可以创建一个路径,指向指定的文件对象;
    文件对象: fileinput框下面的.files属性对象里面存储了file选中的图片;files不支持jQuery;
    返回值是:文件路径
  优点:快速实现实时预览图片;缺点:临时存储;
9,时间日期默认值
      <input type="datetime-local"> 日期和时间的表单框;
      指定日期有固定的格式:2018-07-03T02:05;
      通过原生js获取的日期格式不匹配,需要用getFullYear/getMonth等等拼接字符串;
      时间日期插件:moment.js日期处理类库来格式化;//插件包见课件
          使用方法:   moment(日期对象).format('日期格式');
          返回值是格式化好的日期字符串;
          如果日期对象不传参数,默认是获取当前时间;      
          常用参数:
                      Y  表示年 YYYY 2017
                      M  表示月 MM   07
                      D  表示天 DD   03
                      H  表示时 HH   02//H是24小时制,h是12小时制
                      m  表示分 mm   02
                      s  表示秒 ss   03是小写//S大写是0-99%  1min的意思;
-----------------------------------------------第四天------------------------------------------------------------
1,模板引擎中,可以遍历对象
注意:不可以直接遍历传入template的对象;可以遍历传入对象中的值;
    将模板中可以使用传递进去的数据对象的属性; 
    将需要遍历的对象用对象包裹后传入tenplate中;
     在模板中遍历对象中的对象即可;
     其中数组下标的形参相当于对象的属性名,数组的值相当于属性值;
    {{each state v i}}
    <option value="{{i}}">{{v}}</option>
    {{/each}}  
2,input的  accept属性
作用:可以筛选出具体接收什么文件的类型
书写结构:accept="类型";
eg: accept="image/gif,image/jpeg,image/jpg,image/png"
    accept="image/*";任意图片类型均可
3,收集文件路径,需要收集的是相对于页面访问的路径,少一层../;
4,模态框:有遮盖层的框,遮盖层下的东西不能点击;
5,select框如果要默认选中,可以直接给select指定value,则会指定对应的option被选中;
6,收集表单数据的两种:
  1)$('表单元素form').seralize() 
    表单序列化,将所有带name属性的基本表单元素里面的值获取,拼接成一个字符串格式;
    不能序列化文件;
  2)var 变量名 = new FormData(表单元素form,需要是dom对象)
    可以收集表单信息,也可以收集文件信息;
  3)$.ajax配合FormData使用;
  注意点:(1)可以将FormData 实例出来的对象直接放在data中使用;
        (2)contentType:false;   不进行设置请求头,让浏览器自动检测;默认是true,会进行设置请求头;
        (3) processData:false;   不对传入的对象进行转码/编码;默认是true,会将传入的对象编码成字符串;
-----------------------------------------------第五天------------------------------------------------------------
1,表单重置 dom元素调用,js方法;
  书写结构:表单.reset()
2,input表单的 type类型写reset,就变成了重置按钮
3,seralize();是jQ的方法;
4,数据库中关键字解决冲突的办法``;
eg:   where `key` = site_name;其中key是关键字;
-----------------------------------------------第六天------------------------------------------------------------
1,反馈内容:
(1)nprogress_start();是进度条的一款插件;
一,网络相关阐释和基本概念
    ip地址:计算机在网络中的唯一标识,用来定位计算机的;缺点:不好记
    域名:ip地址的别名;
    DNS: 域名解析;记录ip和域名的对应关系;
    本地hosts:也可以记录ip和域名的对应关系,一般先找本机的hosts,再找网络上的DNS;
    端口:用来区分应用程序的,不同端口对应不同服务;常见:80;3306
    面试题:域名和ip地址一定是一一对应的吗?不一定;
    一个ip对应多个域名;一个域名对应多个ip地址(负载均衡,通过主服务器进行分发到其他服务器,做网络优化的效果);
二,表单提交
基于http协议中,请求的几种方式:
    get/post;常用,创建型的(表单只有这两种)
    put:更新(了解)
    delete:删除(了解)
1,前端页面:
    action: 指定提交的地址;
    method: 指定提交方式(get/post);
    name: 指定给表单元素,后端通过name获取数据;
    enctype: 文件上传的时候要用到;指定值为:multipart/form-data;
2,后端处理表单常用的超全局变量:
    $_POST:
    $_GET:
    $_FILES:
    $_SESSION:获取,操作session数据(使用前start)
    $_COOKIE:获取cookie数据,获取的是请求头中携带的数据,是间接获取的(操作是setcookie)??????;
三.http协议
规定请求和响应的组成部分
1,请求request
构成:(1)请求行:请求地址,请求方式,协议;get请求参数在请求行内
    (2)请求头: 系统或者浏览器对应的版本信息
              主机地址,浏览器相关的系统信息(user-Agent,可以获取用户的浏览器是手机/pc/及版本);
              post请求中:设置请求体的编码方式;
    (3)请求体  传送给后台的参数
2,响应response
构成:(1)状态行 : 协议,状态码,状态文本
    (2)响应头 :服务器相关版本信息,响应体的内容长度(用来进行内容校验,防止内容丢失)
          时间,服务器相关的版本信息,使用php的版本,响应的内容长度,连接超时时间,返回内容的类型
    (3)响应体:响应给浏览器进行解析的信息,
常见状态码:
200:成功
302:重定向,页面跳转的时候(header(location:地址));
403:资源不可用,资源访问受限;请求是成功了,但是服务器限制了,不给返回
404:找不到
500:服务器错误
3,get请求和post请求的区别
get的请求的特点
    1)参数拼接在地址栏,?name=pp&password=123;
    2)不太安全,参数暴露在地址栏
    3)大小4k,不能用于上传文件
    4)传输速度快,不设置请求体编码,没有请求体
post的请求的特点
    1)post参数在请求体中,需要设置请求体的编码方式,设置请求头
    setRequestHeader('contentType','application/x-www-form-urlencoded');
    2)相对安全
    3)大小没有限制,可以用于上传文件;可以在服务器端限制上传文件的大小,修改配置文件即可;
    4)传输速度较慢
http协议的请求方式:get post put delete (基于增删改查);
四,前端可以向后台请求的几种方式
常用请求方式
1,ajax请求
2,表单提交发送请求
3,a标签的href
????????
五,sql语法 
增删改查
    1,插入: insert into 表名(字段,字段)values(值,值)
    2,删除:delete from 表名 where 条件
    3,修改:update 表名 set 字段=值,字段=值, where 条件
    4,查询:select 字段/* from 表名 where 条件
    需求:找出students表中分数最高的前1000条
    select * from students order by scroe desc limit 0,1000;
高级查询
1,where条件
    并且  and   eg:where id>3 and id<10
    或者  or 
    等于  =
    不等于 !=
    大于小于 < >
2,统计条数   count(*)   select count(*) as 变量名 from 表名;
3,一对多匹配 in (常用于批量操作)
    delete from 表名 where id in (3,4,5);
4,模糊匹配like  
    where name like '王%';
5,表的截取(常用于筛选前几条,分页)
    limit 起始索引 ,截取长度
6,排序
    order by 字段  默认升序
    prder by 字段 desc 降序
    新添加的数据显示在第一条:   order by id desc;
7,联合查询
select 表2.字段,表1.字段 from 表1 join 表2 on 表1.字段 = 表2.字段 where 条件;
五,php操作mysql相关api 
1,连接数据库  mysqli_connect(ip,用户名,密码,数据库,端口号);
2,准备sql(外双内单)  双引号可以解析变量;
单引号性能高,不会解析变量;
3,执行sql   mysqli_query(连接对象,sql语句);
  返回值:  1)非查询语句 true/false 
          2)查询语句  成功返回结果集/失败false;  
          连接对象和查询语句成功后返回的结果集,都属于资源型(source)对象,如果要从结果集中取数据,必须用对应的方法
                从结果集中取出来   mysqli_fetch_assoc(结果集);
          3)显示错误信息 mysqli_error(连接对象)
          4)获取结果集的行数 mysqli_num_rows(连接对象)
          5)获取结果集中的数据mysqli_fetch_assoc(连接对象);一次只取一条
          $arr = [];
          while($变量名 = mysqli_fetch_assoc(结果集)){
            $arr[] = $变量名
          }
          6)关闭连接  mysqli_close(连接对象)
七,cookie和session 
cookie 是浏览器端存储数据的容器
      1,设置$.cookie(k,v)
      2,获取$.cookie(k)
      3,设置有效期$.cookie(k,v,{expires:1})
      php操作cookie
      setcookie(k,v,有效期)
      $_COOKIE超全局变量,只能获取cookie
      cookie特点:
      1)大小4k 
      2)请求是将cookie中储存的数据进行携带,携带在请求头中
      3)默认是会话级别的,可以设置有效期
      4)同源网站,可以共享数据
      5)不同浏览器cookie不能共享
session是服务器端存储数据的容器
操作session常用方法
使用前要session_start();
设置$_SEEION['key'] = 'value';
删除unset($_SEEION['key'])
清空?????$_SEEION = [];
用户第一次访问时,session_start开启session后会做的事情:
1,动态生成一个sessionId(随机字符串),
2,根据sessionId动态创建session文件,可以在session存储数据;
3,将sessionId设置在响应头里面,返回给浏览器,浏览器设置cookie存在cookie中,
cookie和session配合实现登录状态保持的思路(浏览器和服务器的访问时无状态的)
1,在登录成功是,记录用户信息
    session_start();
    $_SEEION['key'] = 'value';
2,下次直接从session中取用户数据
    session_start();
    echo $_SEEION['key'];
cookie和session配合实现登录状态保持的思路
1,判断cookie中有没有sessionid
如果cookie中没有sessionid,直接拦截到登录页;
如果cookie中有sessionid,尝试获取用户信息;如果能获取到,认识当前用户,允许访问;如果获取不到,拦截到登录页;
2,退出功能实现思路
服务器端销毁session文件即可  session_destory();
浏览器端也可以清除登录状态,清除浏览器缓存,清除cookie;
八,原生Ajax(XMLHttprequest对象)
发送get请求
var xhr = new XMLHttprequest();
xhr.open('get','路径?参数&参数',true);
xhr.send(null);
发送post请求
var xhr = new XMLHttprequest();
xhr.open('post','路径',true);
xhr.setRequestHeader('content-type','application/x-www-form-urlencoded')
xhr.send('参数');
xhr.onreadystatechange = function(){
  if(xhr.readySate===4){//响应完成
    if(xhr.status===200){//响应成功
      xhr.responeText;处理响应(普通);
      xhr.responeXML;处理响应(xml);
      json_parse(xhr.responeText);处理响应(json);
    }
  }
}
九,$.ajax();
语法: $.ajax({
  url:'地址',
  type:'get',
  data:{
    k:v,
    k:v,
  };//或者data:'?k=v&k=v',
  dataType:'json',    //json xml text jsonp 
  beforSend:函数体,   //发送请求前调用;如果return false;可以阻止此次提交;里面可以进行表单校验,如果没有通过return false;
  success:函数体,     //成功 
  error:函数体,       //失败 
  complete:函数体,    //不管成功或者失败都会调用
})
十,模板引擎(template-web.js)
使用步骤:
  1)引包;
  2)准备模板;
  3)准备数据;
  4)将模板和数据相结合;
  template('模板id',数据对象);
  必须是对象,在模板中可以使用对象中的所有属性
语法:
  1)基本渲染
      {{name}}  //直接是对象内的属性
  2)遍历
      {{each list v i}}
      {{/each}}
  3)判断 
      {{if 条件}}
      {{//if}}


      {{if条件}}
      {{else}}
      {{/if}}
十一,jsonp  解决跨域问题
json with padding 在json数据的外层包了一层函数调用;
jsonp是用来解决跨域问题的,cors也可以解决跨域问题(ie10+)
jsonp和ajax没有关系;
jsonp的原理:
    1)利用script标签可以跨域请求数据的特性,向后台发送get请求;
    2)后台返回一个函数调用,将数据作为参数传递给前端;
    前端配合:
    1)声明一个全局函数
    2)动态创建script标签,将函数名传递给后台
    后端配合:
    1)接收函数名
    2)返回函数调用,将json数据作为参数返回;
真实开发中,前端使用jQuery中封装好的jsonp
$.ajax({
  type:'get',
  dataType:'jsonp',
})
十二,XMLHttpRequest 2.0版
1,超时  超时后就不要返回的数据了
xhr.timeout = 2000;
xhr.ontimeout = 函数体
2,formData 管理表单数据
结构:  var fo = new FormData(表单对象/必须是dom对象);
特点:
  1)只能是post请求
  2)不需要设置请求头
  3)可以作为send的参数
  4)追加 fo.append('name',value);
结合$,ajax使用 
  $.ajax({
    type:'post',
    data:fo,
    contentType:false,//不设置请求头
    processDate:false,//不进行编码
  })
3,上传文件的进度  upload.onprogress 
xhr.upload.onprogress = function(e){
  e.loaded //已上传的;
  e.total //总的;
  toFix(2)//保留2位小数;
}
十三,浏览器输入网址想服务器发送请求的过程
1,输入网址,进行DNS解析,得到ip地址,通过ip地址访问服务器;
2,如果请求的是静态资源文件(js文件,png,html),不需要进行服务器进行解析,直接返回;
3,如果请求的是php等动态文件,会先进行服务器端的解析,再将输出的结果,返回给浏览器;
4,浏览器接收响应,通过渲染引擎进行渲染;
十四,常用插件
1,分页:jQuery.pagination.js 
2,时间格式化:moment.js 
使用:  moment().format('时间格式')//时间格式有:'YYYY-MM-DDTHH:mm'
3,富文本编辑器:wangEditor.js
十五,其他
1,当用户输入的事件:  input事件,可以监听用户输入 
2,控制文件上传的类型:
accept="文件类型/文件类型"
3,图片本地预览: URL.createObjectURL(文件对象)
4,表单重置: 表单dom对象.reset()
5,事件委托的使用场景:
动态渲染的元素;批量注册事件
语法: 父元素.on('事件名','触发事件的子元素',事件处理函数);
原理:事件冒泡
十六,增删改查的思路
总:
  后台接口
  前端请求接口,获取数据(serialize();formData())
  请求完成重新渲染
十七,主页轮播图
1,元素.is('选择器');
判断元素是否符合选择器?是true:否false;
2,轮播的时候,前端写的轮播效果在ajax获取数据渲染之前,所以后面上去的图片没有效果;
解决方法: 将轮播效果封装成函数;在ajax中发送请求成功后,执行渲染函数;
3,轮播图阿里百秀页面无法显示中文;
json_encode()在编码存储的时候,在编码utf-8的时候,会丢失\;所以中文显示不出;
解决方法: 不希望转成unicode的编码形式
    json_encode(数组/对象,JSON_UNESCAPED_UNICODE)
4,遍历的参数总结:
    each(index,element);//jQuery方法
    forEach(value,index);//原生js遍历数组的方法;
-----------------------------------------------今日内容------------------------------------------------------------
传统js文件引入缺点:
    1,引入js是同步引入的,可能会阻塞页面的渲染
    2,多个文件之间可能会存在依赖关系,不方便维护
一,前端模块化,require.js 
1,js文件异步加载,避免网页失去响应;
2,更方便管理模块之间的依赖性
二,模块化的标准
    AMD:异步模块定义 require.js (无兼容问题)
    依赖前置:在一开始就将所有依赖项全部加载;
    CMD: 通用模块定义(国际已不再维护,)
    依赖延迟:在需要的时候才去加载依赖项;
三,使用require.js 
模块的特点:
一个模块,一般都是一个单独的js文件;
一个模块一般有自己的独立作用域;
一个模块 可以有导出项(从模块中导出,让别人使用);
步骤:
  1)引包;
  2)定义模块:
      有自己独立的作用域
      每个模块一般单独的js文件
      语法:define('模块名',['依赖项1','依赖项2'],function(导出项1,导出项2){
        //模块的主体,会在加载完依赖项后调用
        //导出项1,导出项2这两个形参,接收的是来自依赖项1,依赖项2中的 导出项
      })
      注意:
      (1)模块名可以省略,如果省略了,是匿名模块;
      (2)导出项,定义在模块中的方法,希望从模块中导出,给其他人使用;
          如果有导出项,在定义模块中return 导出项;
      (3)依赖项,所依赖的模块,在定义时,声明好了,引入该模块时,会自动进行加载;
          依赖项里面是'路径',依赖其他的js文件;
      (4)定义了模块名的,需要以模块名的方式加载,才能获取导出项;
          对于定义好了模块名的模块,需要在config内定义别名,而且别名要和定义的模块名统一;
  3)使用模块,加载模块,引入模块
      require(['模块路径'],function(ee){
        //是加载完模块,会调用的函数;
        //加载模块是异步的方式进行加载的,需要传递的是回调函数,在模块加载完进行调用;
        //e是定义模块时的导出项;在这个函数中可以直接使用;
      })
      注意:
      (1)模块路径:一般是相对路径;后缀名.js可以省略(推荐省略);
      (2)有导出项的模块: 在函数中申明形参接收导出项;
      (3)有多个导出项,引入多个模块时,会异步加载;互相不干扰;加载完后才会调用回调函数;
      引入的模块路径和导出项的形参是一一对应的;如果,该模块没有导出项;默认return undefind ;
      可以将不需要导出项的路径放到最后,可以不用写其对应的形参;
      (4)如果定义了模块名,需要定义别名,通过别名加载模块;别名与模块名需要统一;
  4)引入模块的路径几种方式; 
  方式1:通过相对路径或者绝对路径,直接引入模块
        相对路径:   ./开始(常用)
        绝对路径:    /根目录开始;要写全,必须写.js后缀;
  方式2:配置 data-main属性,配置公共路径;(了解)
        配置了data-main,真实路径 = data-main配的路径 +模块路径 
        data-main='./js/'   路径写全,最后一个/不能少;
  方式3:配置config,类配置公共目录,还可以配置别名;
      写法:
      require.config({
        baseUrl:'公共路径';  //指定基础公共路径;相对路径/绝对路径均可以;项目推荐是绝对路径
        paths:{             //指定私有路径的别名;使用就可以直接使用别名访问路径;
          变量名1:'私有路径';
          变量名2:'私有路径';
          变量名3:'私有路径';
        },
        shim:{
          变量名:{
            deps:['路径/设置好的别名'],     //配置依赖项;上面配置的别名可以直接用;
            exports:'导出项'               //配置导出项;导出项可以是return出来的导出项,也可以是函数名;
          },
        }
      })
      注意:
        1)找文件的规则:baseUrl+文件路径或者baseUrl+paths;
        2)只要使用了config进行配置路径,就不要给模块路径加上.js路径;
        如果加了.js,会报错,无视baseUrl的配置;
        3)文件路径如果是以/开头,也会无视baseUrl的配置,默认是从根目录开始找的绝对路径;
        4)如果是网络路径,http:// 都是直接按照路径进行读取;
  5)第三方模块的加载; 
  shim(中意:垫片) 内的
  deps可以配置依赖项;
  exports可以配置导出项
  语法: shim:{
          deps:['依赖项的地址/别名'],
          exports:'导出项',
        }
  判断是否支持模块化:
      1)查看官网文档(很多不完善的,老的都查不到);
      2)查看源代码,看里面是否有define()
      3)如果定义了模块名,需要定义别名,通过别名加载模块;别名与模块名需要统一;
  不支持模块化-有依赖项:   即没有define([],函数体)
      1)不支持模块的,没有依赖项的可以直接引入即可;
      2)如果不支持模块化,有依赖项,在js中没有定义依赖项;
       不会自动加载'依赖项',需要手动添加'依赖项',利用shim可以配置deps依赖项;
  不支持模块化-有导出项:   即没有define([],函数体)
      3)在shim中设置exports导出项;

















