-------------------------------------复习--------------------------------
继承:
原型继承:用来继承公用属性(公有的属性基本上都写在原型上,而我们原型继承就是把我们写在原型上的属性继承下来)
               function Per(){};
               Per.prototype.say = function(){};
               function Stu(){};
原型继承语法1   Stu.prototype=new Per();//将Stu函数的原型对象指向改为Per的实例;就能继承Per原型身上的方法(Stu的实例都可以顺着原型链访问到)
               var s = new student();//此方法要找两步;但是两个原型可以分开管理,三角关系保持
               s.say();//
原型继承语法2   Stu.prototype=Per.prototype//此方法更快,一步找到;但是共用一个原型,没有分开管理,三角关系不保持

Function的原型问题:
        Function自己创造了自己
        Object是Function的实例
        不管是谁,原型链最终一定是指向了Object的原型,再往上就是null
js是一门单线程的语言
单线程的特点:一次只能做一件事,做完一件事,才能做下一件事
      堆:存储引用数据类型
      栈:存储基本数据类型,变量也会在栈里,所有的代码执行的时候,都是要加载到栈中


事件轮询机制:
V8引擎:执行js代码的地方(堆,栈)
webapi:帮助js计时
事件轮询:会一直观察栈和任务队列,并且会把任务队列中的任务拿到栈中执行
任务队列:存储定时器时间到了之后/触发了之后的事件处理函数
执行过程:  比如说,注册事件,设置定时器,当在栈中,执行了这些代码,定时器计时的工作,或者是存储事件的工作就
          交给了浏览器,当定时器的时间到了/事件触发了,浏览器会把定时器的回调函数/事件处理函数存放到任务队列中等待执行,
          当栈里面的代码执行完毕了,事件轮询会将任务队列中的第一个任务拿到栈中执行,任务队列会一直重复刚才的动作

闭包:
MDN:函数和函数作用域的结合
俗语:内部函数引用了外部函数的变量,外部函数形成了一个闭包
作用:
     (1)私有化数据
     (2)私有化的基础上保持数据
缺点:由于内部函数引用了外部函数的变量,导致外部函数无法出栈,有可能会导致栈溢出
-------------------------------------今日内容--------------------------------
一,面向对象
面向过程:
    一步一步的具体去做这个事情
面向对象:
    面向对象是对面向过程的封装;
    找对象,调用对象的方法;
    需要哪个对象,调用这个对象的某个方法,帮助我们实现具体的需求;
    优点: (1)维护起来更方便
          (2)团队协作更加便捷
二,贪吃蛇案例
1)由于贪吃蛇的游戏中,Food只new一次,所以获取随机数的代码不写在构造函数中
  为什么要把这个方法放到原型上?因为蛇吃掉食物后,还要继续随机生成食物(继续调用这个方法)
2)一般把公共的方法放到tools.js中,并存放在Tool{属性:方法,....}中,可以增强团队协作


















引申:          
arguments:是函数中的一个对象,而arguments是一个伪数组,里面存储了所有传进来的实参


















