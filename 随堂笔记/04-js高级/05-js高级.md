-------------------------------复习-----------------------------------
一,面向过程,面向对象
面向对象是对面向过程的封装
二,贪吃蛇案例
1,利用构造函数创建对象
2,利用构造函数的原型对象,把公用方法放到原型上
3,构造函数内设置可外部设置,可自定义的形式(||)
4,在生产环境下:
 有很多js文件需要引入的时候,可以把四个js文件合并到一个js文件里面,这样只需要引入一次,提高效率;
把需要合并的单个js文件里面的内容,按照依次的顺序,把单个js内容依次复制粘贴入总的js文件里面(注意用;隔开)
如果不写;   浏览器会把      内容内容(function    内容内容(在调用它的方法,而它没有函数方法,所以需要用;隔开
    1) 用{}后面不用写;
    2)  有人这样写:   
      ;(function(){函数体})()
      (function(){函数体})(window),如果这样写,函数里面的window就是个变量名,就可以代码混淆;
      (function(){函数体})(undefind),很早很早以前undefind是可以被赋值的;
      在一些老的项目中,可能会看到有人传递window,undefind进来,目的就是为了压缩;传递undefind是因为,在以前的浏览器中
      undefind可以被赋值,所以可能有人会使用undefind;
    3)在生产环境下需要删除注释(有工具可以快速删除)
     删除注释可以使文件变小,增加加载效率;可百度搜索js在线工具(压缩)
    4)js标识符混淆(使变量名等等精简,代码量更小,也不希望别人看得懂,但是机器看的懂)



三,正则表达式
定义:正则表达式是对字符串操作的一种逻辑公式
作用:判断字符串是否符合规则;提取指定部分;替换指定部分
组成:普通字符,特殊字符
    在js中,js把正则表达式抽象成一个对象,通过new RegExp()可以创建正则,英文缩写Reg(规则)Exp(表达式)
    结构:  
    var 变量名 = new RegExp();
    var 变量名 = /内容/;两个//,如果中间没有是注释,中间随便写什么内容就是正则表达式字面量形式;
匹配结构:
正则对象.test(字符串)   如果字符串符合正则公式,返回true,否则返回false;
常用特殊字符:
元字符:
(1)   \d   数字   辅助记忆digital                只要字符串中有数字就true
(2)   \D   非数字                               只要字符串中有非数字就true
(3)   \w   数字,字母,下划线   辅助记忆word        只要字符串中有数字或字母或下划线就true
(4)   \W   非数字,非字母,非下划线                只要字符串中有非数字或字母或下划线就true
(5)   \s   空白字符      辅助记忆space           只要字符串中有空白字符就true
(6)   \S   非空白字符                            只要字符串中有非空白字符就true
(7)   .    除了换行符以外的任意字符               只要有非换行符就true
(8)   ^    以谁开头      eg:  ^a                只要字符串以a开头就true
(9)   $    以谁结尾      eg:  a$                只要字符串以a结尾就true
   引申: /^abc$/   要求字符串中只能有abc
        /^\d$/     要求字符串中只能有一个数字
        /^\d/d$/     要求字符串中只能有两个数字
限制符:
(1)     {n}        代表前面的字符可以出现n次
         {n,}       代表前面的字符可以出现n次及以上
         {n,m}       代表前面的字符可以出现n-m次
        eg:  /^\d{12}$/     要求字符串中只能出现12次数字则为true,其他都不行
             /^\d{3,}$/     要求字符串中只能出现3次数字及以上则为true,其他都不行
             /\d{3,}/       要求字符串中只要包含3次数字及以上则为true
             /^\d{3,5}$/     要求字符串中只能出现3-5次数字则为true,其他都不行
(2)     *          代表前面的字符出现0-多次
(3)     +          代表前面的字符出现1-多次
(4)     ?          代表前面的字符出现0-1多次
        eg:  /^\d*$/     要求字符串中要么什么都没有,要么只能是数字     
             /^\d+$/     要求字符串中至少出现一个数字     
             /^\d?$/     要求字符串要么什么都没有,要么只能有一个数字    
其他字符:
(1)      []      中括号占一个字符的位置,在中括号中选一个字符
                  eg:  /^[abcd]$/  只能有一个字符,并且只能出现一次
(2)      [^]    中括号占一个字符的位置,不能出现中括号中的字符 
                  eg:  /^[^abcd]$/  只能有一个字符,并且不能出现abcd中的任意一个
(3)      \        转义符        把特殊字符转换成普通字符;把普通字符转特殊字符
                   eg:  /^[\.]$/  只能有一个.
(4)      |     会把正则分成两部分
                 eg:  /^a|b$/  以a开头或者以b结尾
(5)      ()     分组
                eg:  /^gr(a|e)y$/  gray或者grey
(6)    [内容1-内容2]    从内容1到内容2的
         eg: [a-z]   小写字母a到z;
             [a-Z]     错误的;
             [A-z]     大写的A-Z;
             [\u4e00-\u9fa5]   匹配汉字,从'一'到'龥',所有的汉字  
匹配,提取,替换
1,匹配:   正则对象.test(字符串) 
        返回值true/false
2,提取:    字符串.match(正则对象)   实际是字符串的方法
          返回值:一个数组
          正则的参数: g     全局的意思,使用结构:    /正则表达式/g
  引申:   正则对象.exec(字符串)     基本不用,因为永远只拿数组的第一个,拿不了全局
3,替换:    字符串.replace(正则/被替换的字符,替换的字符)
注意点:
1) new RegExp (参数1,参数2)
参数1 '字符串的表达式'
   结构:  new RegExp('字符串的表达式')
   new RegExp('\d')这么写,不认为是数字字符,去匹配了\d的字符串
   new RegExp('\\d')第一个\是转义符,第二个\是特殊字符转义符,再把d转义了
2)   new RegExp('字符串的表达式',参数)
3)分组  
数字3位.数字3位.数字3位
把需要重复的正则表达式用(内容){n},内容重复n次
  配合正则对象身上的静态属性
结构:   (需要匹配的内容)
 正则对象.$1;分组匹配结果$1,$2,$3....  把需要匹配的内容按照一组来提取







事件:   blur  失去焦点事件
一般在公司开发中,获取用户输入的信息要trim一下,去掉两边的空格
字符串的方法 :   trim()               

