----------------------复习------------------------
反馈内容:
1)借用构造函数继承,必须全部借用,不能只借用其中几个
2)预解析规则-会预解析://其实是内存先加载了,看似是把代码提前了;
        (1)用var申明的变量
       (2)申明的函数   
        var fn = function(){}   //函数表达式,只提升var fn;
        function fn(){}         //函数申明,整体提升
如果预解析和函数重名了,一定是函数覆盖变量;书写顺序不重要,都是先提升变量,后提升函数,所以后面的函数把前面的变量名覆盖掉而已
总结:所谓预解析,实际是把申明的变量和函数提前加载到内存中,在代码的角度上讲,就好像把申明的变量和函数写在了最上面,所以又叫变量提升;
实际上,变量和函数提升的时候是有先后顺序的,不管你在代码中如何书写,提升时,一定是先提升变量,后提升函数,由于函数后提升,所以覆盖了变量;
instanceof:
    判断函数的原型是否在对象(实例)的原型链上
原型链不可变:一旦实例被创建出来之后,他的原型链就固定, 不会随着函数原型的变化而变化
上下文调用模式:
    call    会调用函数
    apply   会调用函数 ,第二个参数传数组
    bind   不会调用函数,克隆一个新的函数
js继承:
 单个对象之间的继承:
 拷贝继承
 新对象= Object.create(被继承的对象)    新的对象__proto__ =被继承的对象
 构造函数之间的继承:
 借用构造函数继承
 function Far(name,age){
   this.name = name;
   this.age = age;
 }
 function  Son(name,age,score){
  Far.call(this,name,age);
  this.score = score;
 }
 ----------------------今日内容----------------------------------
一,原型继承
如果想要继承原型上的属性,就要使用原型继承这个方式
eg:  
1)需要继承的函数.prototype = new 被继承的构造函数();  专门用来继承写在原型上的属性
        function Far(name,age){
            this.name = name;
            this.age = age;
          }
          function  Son(name,age,score){
           Far.call(this,name,age);//借用构造函数继承:只能继承私有属性,如this.XXX属性
           this.score = score;
          }
           Son.prototype = new Far();//原型继承:继承公有属性,专门用来继承写在原型上的属性
           //将son的原型指向为Far函数造出来的实例,不再指向原来Son的原装原型
2)   需要继承的函数.prototype =被继承的函数.prototype
     将需要继承的函数原型指向被继承的函数的原型
    这种方式找的时候快一点,但是他们关系有点乱,没有一个完整的三角关系;如果想修改公有属性的话,只能在被继承的原型对象上增加
属性写在构造函数中,方法写在原型上;
私有属性写在构造函数中,公有的属性写在原型上
借用构造函数法用来继承私有属性,原型继承用来继承公有属性

二,组合继承
定义:借用构造函数,原型继承,共同使用;

三,js中继承(主要是对象和对象之间的继承)
1)单个对象的继承 
 拷贝继承  for..in 
 新的对象 = Object.creat(被继承的对象);新对象.__proto__ ==被继承的对象
2)构造函数的继承    (实际还是对象与对象之间的继承,批量继承)
 在实际工作中,经常要批量创建对象,所以要用到构造函数


四,拓展
1,函数的静态成员和实例成员
成员:泛指属性和方法
实例成员:最终加到实例身上的属性和方法,就是实例成员
         this.属性/方法  这个属性,最终new函数的时候,是添加到实例身上的属性 
    引申:  实例不能直接访问到函数自己的属性(函数的静态成员),可以访问到函数原型的属性
静态成员:函数也是对象,函数自己的属性    
        函数.属性/方法  这个属性是直接添加到函数身上的(函数也是对象数据类型)
2,函数的原型
函数创建方法:
(1)function fn(){}
(2)var fn = function(){}
函数创建的时候,其实是在底层做了
var fn = new Function(参数1,参数2,参数3)
        参数1:形参1
        参数2:形参2
        参数3:函数体
所以说函数也是对象
    Function自己创造了自己
    Object是Function的实例
    先有函数,函数new出来的Object 
    不管是谁,原型链最终都指向了Object的原型,再往上就是null


五,js单线程和事件轮询机制
    js是一门单线程的语言
        意义:js诞生是为了表单验证,势必操作DOM,假如js是多线程,一个线程要删除元素,另一个要给元素添加样式
            ,这样的话,js就不知道要做什么了,为了避免这个问题,js从一开始就设计成了单线程
        定义:js在工作的时候,一次只能做一件事,做完一件事才能去做下一件事情
        引申: 
        1,  java是多线程语言,一次可以做好多事
        2,  ppt讲解:
        1)栈和堆
            HEAP   堆:引用数据类型存在堆里,在堆里开辟一块空间,把地址(地址是16进制的数)给栈那边的变量名;
            STACK  栈:基本数据类型存在栈里,变量名会进栈,基本数据类型会存在栈里,引用数据类型的地址(16进制的数,那就是数字类型),存储在栈的变量名内;
            总结:在内存中有两块区域,一个是栈(stack),一个是堆(heap)
                 栈用于存储基本数据类型,变量都是在栈里,引用数据类型的地址由于是16进制的数字,所以也存在栈里
                 堆用于存储引用数据类型,
                 栈存储数据是有大小限制的,而基本数据类型的大小是有限制的,所以存在栈里;
                 堆存储数据没有大小限制的,而引用数据类型的大小也不知道最大是多大,所以存在堆里;
        2)  js中,所有代码执行的时候,都会加载到栈中执行;
        3)  函数申明的时候,函数会存放在堆中;
            函数调用的时候,函数内的所有数据会被打包(类似于复制一份),加载到栈里面,在栈里面执行完毕后,再将函数出栈(弹栈),数据销毁;
            如果此函数没有执行完(比如递归,比如函数内部调用其他函数),则函数会继续在栈中,直到执行完毕;
            如果在栈中的函数遇到了错误,那么会停留在报错的一行,不会继续往下执行了;
        4)事件轮询机制:    v8引擎(栈和堆) , event loop(事件轮询),webapi(浏览器),任务队列
        v8引擎(栈和堆):执行每一行代码;
        webapi(浏览器):提供了很多方法,帮助我们计时;
        event loop(事件轮询):一直观察栈和任务队列:如果栈中的代码执行完毕了(栈空了),就去任务队列中拿第一个任务放到栈中执行,会一直不停的重复执行刚才的动作;
        任务队列:定时器的回调函数/事件处理函数触发时,不会立即加载到栈中执行,会先存储到任务队列中排队,如果栈里面的执行完了,才会拿任务队列中的当前排位第一个执行;
              在执行的时候,如果遇到了(需要多线程控制的,如定时器的回调函数),会先把定时器给到webapi;
              webapi开始计时,时间到了之后,定时器中的回调函数会被event loop放到任务队列中,event loop会观察检测栈里面的任务执行状态,
              一旦栈中执行完代码了,是空的时候,event loop会把任务队列中正在排队的回调函数放到栈中开始执行,如果是setInterval,就会有好几个回调函数在任务队列中排队
              老师总结的:  js中,所有代码执行的时候,都会加载到栈中执行,如果有定时器/时间处理函数,不会立即执行,他们会先在浏览器案例暂时管理一下,当时间到了/事件被触发了,
                       浏览器会把回调函数/事件处理函数,放到任务队列中排队,当栈里面的代码执行完毕了,事件轮询就会把任务队列中的第一个拿到栈中执行,执行完毕之后,事件轮询还会去任务队列中拿下一个,再放到栈里面执行
        5)alert(),propmt(),confirm(),这种弹窗类的代码会阻塞代码执行;弹窗的过程当中,这个代码并没有执行完毕;
                这个代码执行完毕之后,才会接着执行下面的方法;
                阻塞的时间里,别的代码(如果有定时的代码)并没有排在执行队列中;
ppt讲解引申:
手动创建一个错误
结构:  new Error('错误内容') 
将错误报出来:
    throw new Error('错误内容');//抛出一个报错内容为:错误内容



六,闭包
1,递归回顾
定义:函数中自己调用自己
注意:
    1)如果要写递归,必须给一个出口,如果没有一定会造成栈溢出
     栈溢出:  栈里面放不下了,栈溢出会报错Maximum... 
    2)自调用函数不是递归,把申明函数和调用函数合成一步,西面就是自调用的写法
      自调用函数结构:  (function(){})()
2,闭包
MDN的概念:是函数和函数作用域的结合    
定义:通俗理解的闭包就是一个内部函数引用了外部函数的变量,外部函数形成了一个闭包
结构  :
        eg  :
        function  outer(){
            var i = 0;//把数据放到函数内部,数据相比于全局更安全,达到私有化数据
            return {
                变量名1:function inner(形参){
                console.log(i);//可以操作私有化数据
            },
            变量名2:function inner(){
                函数体;
            },
            ....
        }
        }
        在函数外部访问时:
        var 变量名 = outer();//会把返回值给到变量名,所以变量名身上有一个对象,可以有多个方法直接调用,也可以修改函数内部的数据
        变量名.变量名1(形参);//就可以访问内部并修改数据,执行函数体即可;
作用:
    1)私有化数据
    2)私有化数据的基础上要保持数据
缺点:
    由于内部函数引用了外部函数的变量,导致外部函数执行完毕无法出栈(弹栈),如果代码中大量写了闭包,有可能会导致栈溢出
引申:
java:编译型语言,虚拟机编译成.class
脚本语言:不需要编译,执行一行解析一行










