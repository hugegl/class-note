-------------------------复习-----------------------------
1,原型:函数创建出来的时候,浏览器就会自动创建一个函数对应的对象,这个对象我们成为原型对象(简称原型)
2,获取原型:函数.prototype  找到这个函数对应的原型
          原型的属性:   constructor可以访问到自己(此原型)对应的函数
3,实例:通过new构造函数创造出来的对象,可以默认访问自己对应构造函数的原型
       实例身上的属性:    __proto__可以访问到对应的函数的原型 但是不是标准属性,不建议在生产环境下使用
4,原型链:  实例  ===> 原型 ===>原型的原型...==>null     
5,对象查找属性的规则:先在自己身上找,如果有就用,如果没有就顺着原型链往上找,如果找到了就使用,如果找不到就继续往上找,直达null,如果还是没有返回的是undefind
-----------------------------------今日内容--------------------------------
一,内置对象的原型
定义:内置函数的原型上定义了我们之前学习的那些常用方法
通过内置对象创建出来的对象是内置对象的实例,可以访问这个构造函数的原型
eg :  var arr = new Array();/var arr = [];底层帮我们new Array()
    所以,所有数组都是Array的实例,所有的数组都可以默认访问到Array的原型,此原型身上有很多方法和属性,这些实例数组都可以访问到原型上的方法
数组的常用方法都是放到原型上的,优点:节省内存

引申: object的原型中toString()方法返回的是[Object Object]字符串,Array的的原型自己的toString()方法返回的是将数组内容转换成字符串



二,给原型添加自定义方法
    1)只添加一行,或者一次
        结构:  函数.prototype.新方法 = 值  
        函数内的this,谁调用就指向谁,如果没有写return就没有返回值,写了return就有返回值
        此方法是追加一个属性,不改变函数原型的指向及原来原型的其他属性/方法;
    2)批量增加
    原理:因为函数的原型是谁,是由函数的prototype属性指向决定的
        利用对象赋值多个自定义方法
        结构:
            函数名.prototype = {
              方法名1:方法1(函数),
              方法名2:方法2(函数),
              方法名3:方法3(函数),
              ...
              constructor : 函数名;//需手动加上,不然会丢失这个属性,原型无法指回自己的函数
            }
        注意:这样创建新方法是改变了这个函数的prototype指向,这个函数就不再指向原来默认的原型了,现在指向了新的对象(因为prototype指向发生了变化)
            如果要使用这个方法改变函数的原型,需手动增加一个constructor指回这个函数;


三,instanceof
作用:js基础阶段:用于判断对象是某个函数的实例,用来判断对象的类型是谁(方便教学当时的基础理解)
     js高级阶段:判断一个函数的原型对象是否在实例(对象)的原型链上(真实作用)
结构: 
  对象实例 instanceof 函数名
  返回值:true 此函数的原型在此对象实例的原型链上;false此函数的原型不在此对象实例的原型链上
原型链不可变:一个实例一旦创建出来,他的原型链就固定了,不会随着函数原型的改变(改变函数的prototype指向)而改变


四,函数中this指向谁
    在函数调用的时候就决定了this的指向,谁调用函数,this就指向谁
      判断this的指向,遵循两条原则:
    1)我们要判断的this在哪个函数中
    2)这个函数是哪种调用模式调用的
 注意: 1)如果直接调用函数,其实相当于window.函数();所以此时this指向window
      2)new调用函数this ==>新创建出来的 实例对象;new控制了this的指向
      3)定时器调用时,setInterval(函数,时间),函数内的this指向window
(1)上下文调用模式
其实就是js中提供给我们的三个方法,而这三个方法的作用就是随意控制函数中this的指向
  1)  call
  作用:1)调用函数;
       2)指定函数中this指向
  结构:    函数.call(参数1,参数2.....)
  参数1     this指向参数1
  参数2及...    是传递给函数本身的实参,和函数的形参一一对应
  2)   apply
  作用:1)调用函数;
       2)指定函数中this指向;
      3)实参需要放到数组中
  结构:     函数.apply(参数1,[参数2])
  参数1    this指向参数1
  参数2    必须是个数组,数组内是函数的实参;如果不写数组会报错
  3)   bind
  作用: 1)克隆当前函数,返回克隆出来的新函数(不会调用函数);
       2)指定新克隆出来的函数中this指向
  结构:  函数.bind(参数1,参数2...)
  参数1     this指向参数1
  参数2及...    是传递给函数本身的实参,和函数的形参一一对应
  函数的实参可以在bind的时候传,也可以在新克隆的函数调用的时候传实参
总结:上下文调用模式三个方法
   1)  call和apply都会调用函数 
   2)  call和bind的传参方式是一样的
   3)  bind不会调用函数,只会克隆一个新的函数,这个新函数中this已经被指定了(即bind时的第一个参数)
   4)  apply中的第二个参数,要求传入一个数组,这个数组中包含函数需要的实参
   5)这三个方法第一个参数都是控制函数中this的指向,传谁,函数中的this就指向谁
引申:   
1)让伪数组使用数组的方法:
    Array.prototype.数组的方法.call(伪数组名,数组的方法需要传的参数)
2)bind的使用场景
     eg:   for (var i = 0 ; i < divs.length; i++){
                divs[i].onclick = fn;
            }
     function fn(){
            // console.log(this);//在这个函数内this指向当前点击的这个li
            setInterval(function(){
            console.log(this);//如果不加bind,这里的this默认指向window,因为这个函数是定时器调用的,此函数默认指向window;
            }.bind(this),1000)//函数.bind(this),这里的this是在外面这个函数作用域内,这个this是指向了当前点击的li;
                                 //在bind的语法中,函数.bind(参数1);前面的函数可以是函数名,也可以实体函数
            }
    如果使用call或者apply,那么会调用原来的函数,而没有返回值,所以在点击的时候会执行一次,不会每隔一秒执行一次;因为先用call执行了一次,所以会有一次打印结果
如果使用call或者apply的效果是:
setInterval(undefind,1000);因为原来那个函数执行过后的返回值是undefind,这样写没有意义,定时器也不会进行
3)使用场景总结:
  当我们需要自己调用函数,并且要修改函数中this的指向的时候,用call/apply 
  当我们不需要自己调用函数,要浏览器帮我们调用(如,事件处理函数,定时器的回调函数),并且要修改函数中this的指向,我们就可以用bind
  bind的注意点:当new和bind返回的函数一起使用的时候,函数中this指向的还是new出来的实例对象(面试题,new比bind更强大,能更改this的指向)

五,继承
意义:代码优化
1,对象和对象之间的继承常用方法:
     1)拷贝继承(了解)
     结构: for(var 变量名 in 父级对象){
         if(!子级对象.hasOwnProperty(变量名)){
             子级对象[变量名] = 父级对象[变量名];
            }
        };
    hasOwnProperty
    定义:对象的属性
    结构:对象.hasOwnProperty('属性名')    如果有返回true,没有返回false
    2)  Object.create()继承     (有人叫经典继承,常用)
    结构:   Object.create(被继承的对象)
    返回值:一个新的对象,继承了被继承的对象的属性和方法,也有自己的属性和方法
    关系:   新的对象.__proto__==被继承的对象
    这是新对象与被继承对象之间的联系,这个新对象不是通过函数new出来的,而是通过调用函数Object.create(被继承的对象)这个方法返回出来的,
    返回出来的值就是一个新的对象,所以这个新对象不是Object的实例,而是这个新对象与被继承的对象的关系是继承关系,就是新对象.__proto__==被继承的对象
2,构造函数的继承
    1)借用构造函数法
    eg:  
    function far(name,age){
        this.name = name;
        this.age = age;
      }
      function son(name,age,dada){
        far.call(this,name,age);//利用上下文调用的模式,call中让函数far里面的this指向son里面的this,也就是指向调用函数son的这个new出来的新实例对象
        this.dada = dada;//因为在son函数内,所以这个函数内的this都指向new出来xiaohu实例.
      }
      var xiaohu = new son('胡歌',18,'帅帅哒');
    








