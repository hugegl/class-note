----------------------------------------------------------------第一天-----------------------------------------------		
一,canvas的介绍
	定义:是h5新增的标签,画布标签;是个行内块元素;
	canvas本身只是一个画布,需要通过js对画布进行绘制,本身不具备绘图的能力;
	应用场景:游戏;数据可视化,图表;动画;vr(虚拟现实)
二,canvas标签的介绍
	1,默认宽300,高150;
	2,兼容性较大,IE8-不兼容;
		解决方案:给用户提示;
	3,不建议用css设置宽高,是把 像素点放大,拉伸的效果,并不会增加像素点;
		使用属性设置宽高;
	4,canvas只是画布,本身不具备绘图能力,如果需要绘制,需要获取canvas的api进行绘制;
三,如何绘制
	绘制的方法需要写在script标签内
	步骤:1)获取canvas标签
			var cs = document.querySelector('canvas'); 
		2)获取canvas相关api
			var ctx = cs.getContext('2d');//如果是3d  参数是'web gl';
		3)使用api绘制
			书写结构:  ctx.属性 = '值';  ctx.方法('参数');
四,常用api
	1,移动画笔	moveTo(x坐标,y坐标);//将画笔移动到位置;
	2,画轨迹		lineTo(x坐标,y坐标);//画到该坐标的位置;只是构成了路径;
	3,描边		stroke();//默认是黑色
	4,闭合路径	closePath();//自动闭合;会让画笔的终点和路径的起点进行连线;会自动把缺角补起来;
	5,画笔线宽	lineWidth = 值;//值直接写数字;
	6,填充		fill();填满颜色;默认是黑色;
		填充规则:非零环绕;
		非零环绕:1)判断区域是否填充;
				2)从区域拉一条直线出来,和这条直线相交的路径方向之和;
					顺时针+1;逆时针-1;
					如果相交的边是奇数,就填充;偶数的话,需要计算是否为0;
				3)如果所有的路径之和是0则不填充;!0就填充;
	7,描边颜色	strokeStyle = '颜色';颜色语法同CSS;
	8,填充颜色	fillStyle = '颜色';
	9,开启新路径	beginPath();//stroke和fill调用时,会把开启新路径之后的路径全部绘制一遍;所以要开启新的画笔,恢复到默认状态
				一般绘制新模块之前,调用一下beginPath,防止对之前代码的污染;
				调用beginPath();之后要重新移动画笔;
	10,虚线		setLineDash([数字,数字]);数组中的每个元素,依次对应每个实线,虚线的长度,并且对数据平铺;
				getLineDash();获取虚线的数组;获取的是不重复的那一段的排列方式;
	11,	路径矩形		rect(x坐标,y坐标,width,height);绘制矩形的路径
		描边矩形		strokeRect(x坐标,y坐标,width,height);描边矩形,使用了之后就不能用fill()填充;
		填充矩形		fillRect(x坐标,y坐标,width,height);填充矩形,使用了之后就不能用stroke()描边;
		清空矩形		clearRect(x坐标,y坐标,width,height);清空矩形区域
	12,圆弧			arc(x坐标,y坐标,半径,起始弧度,结束弧度,true/false);true是否逆时针,默认是false顺时针;
		角度/360 = 弧度/2PI;
		角度/180 = 弧度/PI;
		弧度 = 角度/180*PI;
		绘制圆弧之前,如果移动过画笔,圆弧的起点会自动和移动的坐标点进行连线;

引申:
1,代码片段
	1)scope:起作用的区域;可以设置JavaScript/html;不写就是全部起作用;
2,hsla颜色模式;
	rgba();a alpha透明度;
	hsla();h色调 0~360 所有颜色都取一遍;s饱和度 0~100%;l亮度 0~100%;a透明度 0~1;
3,刷新的时候页面在转圈,顺时针在响应,逆时针在请求;

----------------------------------------------------------------第二天-----------------------------------------------		
一,反馈
1,清空画布的方式
	1)clearRect(0,0,画布.width,画布.height);//可以清空整个画布后者任意矩形区域;
	2)画布.width = 画布.width;//或者 画布.height = 画布.height;//只能清空整个画布;
2,strokeRect()绘制的描边矩形,不能用fill()进行填充;	
3,fillRect()绘制的描边矩形,不能用stroke()进行描边;
4,线帽样式		lineCap = '参数';round 圆角;butt 默认值 无效果;square 正方形线帽;
5,线拐角的样式	lineJoin = '参数';round 圆角;bevel 平角;miter 尖角,默认值;
二,复习
canvas 是h5的标签;不要使用css设置样式,会拉伸画布;
获取canvasAPI:   var ctx = 画布.getContext('2d');
API:
	moveTo(x,y);
	lineTo(x,y);
	stroke();
	fill();
	lineWidth = '颜色';
	strokeStyle = '颜色';
	fillStyle = '颜色';
	
	beginPath();
	closePath();
	
	矩形
	rect(x,y,w,h);
	strokeRect(x,y,w,h);
	fillRect(x,y,w,h);
	clearRect(x,y,w,h);
	
	圆弧
	arc(x,y,start,end,是否顺时针);
	圆弧:start end 是弧度 弧度 = 角度/180*Math.PI;
	
	圆弧绘制特点:
	在绘制圆弧前,有移动过画笔,画笔的做标签会自动和圆弧起点进行连线
	
	绘制扇形时:
	1,moveTo(x,y);移动画笔到圆心;
	2,绘制圆弧
	3,closePath();

-------------------------------------------------今日内容------------------------------------
一,常用API
	1,图片绘制		先创建图片   var img = new Image();创建图片对象;
								img.src = '图片路径';//
								建议放在加载事件之后;
								路径在加载事件之前路径加载完成,就不会触发加载完成事件;//所以把路径放在注册加载事件之后;
								监听图片加载事件,load,在加载完成后再在画布上绘制图片;
					三个参数		drawImage(图片对象,x,y);图片对象,绘制哪张图片;xy是图片在画布上的坐标,以左上角对齐;
					五个参数		drawImage(图片对象,x,y,w,h);w,h是图片的大小;缩放效果;
					九个参数		drawImage(图片对象,sx,sy,sw,sh,dx,dy,dw,dh);从原图片中截取指定区域绘制在canvas中的指定区域;
								参数详解: 	sx,sy:原(图片),x,y哪个区域;
											sw,sh:原(图片),w,h取多大;
											dx,dy:目标(图片),x,h画在哪里;
											dw,dh:目标(图片),w,h画多大;
	2,设置字体		fillText('内容',x,y);填充文字
					strokeText('内容',x,y);描边文字
	3,字体样式		font = '字体大小   字体样式';写法同css
	4,获取文本宽度	measureText('内容')返回的是一个对象,里面有个width属性存储文字的宽度;//使用时写 measureText('内容').width;
	5,文字对齐方式	水平		textAlgin = '参数';start 默认,文本在指定位置开始;end 文本在指定位置结束;center;left;right;
					基线		textBaseline = '参数';top;middle;bottom;alphabetic 字母基线 默认;//实际使用用xy微调;
二,画布的状态
	1,保存当前画布的状态;各个样式的属性,线宽,线型,颜色,字体大小;
		save();//保存画布当前的状态,以便后面进行恢复,可以继续使用保存过的样式;
	2,恢复
		restore();恢复画布最近一次保存的状态,状态只能恢复一次;想恢复前两次的就多恢复几次,跟保存的一一对应,但是如果恢复了中间的没有使用,会状态丢失;
		数据存储形式;队列是先进先出;栈的存储是先进后出;跟js的堆和栈不是一个栈;
三,变换
在原有的基础上发生变化;
变换的本质是改变坐标系,当坐标系发生改变,新坐标系里面绘制的所有元素都会发生改变
	平移  translate(x,y);x,y分别平移的距离;
	缩放  scale(x,y);x,y分别放大的的倍数;
	旋转  rotate(弧度);
四,插件的使用;
echarts插件百度查询插件使用,开源免费;详细参考官方api;配置项手册;
使用步骤:1)引包
		2)准备容器
		3)初始化echarts实例
		var myshart = echarts.init(document.getElementById('准备的DOM元素'));
		4)准备图标数据;//是一个对象
			var object = {
				//标题
				title:{text:'25期前端就业薪资'},
				//提示工具
				tooltip:{},
				//图例
				legend:{data:['薪资','体重']},
				//x轴
				xAxis:{data:['第1组','第2组','第3组']},
				//y轴一般根据数据自动生成;
				yAxis:{},
				series:[
				//图表核心数据
				{name:'薪资',
				type:'line',//bar柱状图 pie饼图
				data:[12000,13000,15000]//数据
				},
				{
				name:'体重',
				type:'line',
				data:[80,90,110],
				}
				]
			}
		5)将数据传递给echarts实例,生成图表;
		myshart.setOption(object);
五,渐进增强原则
	进行开发时,值需要让低版本的浏览器能使用基本功能即可;
	随着浏览器版本的提高,用户体验越来越好;








案例:
1,六等分的圆
	1)上一个扇形的终点是下一个圆弧起点;循环外面用变量接收当前遍历的圆弧的终点;
2,帧动画,小鱼游泳
	1)同时加载多个图片的时候,互相嵌套;
		eg:  图片1.onload = function(){
			图片2.onload = function(){
			绘制图片1;
			绘制图片2;
			需要执行的代码;
			}
			图片2.src = '路径';
		}
		图片1.src = '路径';
3,撕衣服
	1)两张图片,有遮挡层的先加载;
	2)当鼠标在图片上移动的时候,获取鼠标在遮挡层图片的坐标;
	3)去无遮挡层对应的区域,截取对应图片的绘制在画布上;
	4)监听鼠标移动mousemove和鼠标按下事件mousedown,鼠标抬起事件mouseup;
	5)在mousemove时判断是否按下,用flag标记true/false;
	6)	screenX/Y;相对屏幕的X和Y;
		offsetX/Y;相对于当前DOM元素左上角偏移的X和Y;//此案例用这个;
		pageX/Y;相对于页面的X和Y;
		
		











