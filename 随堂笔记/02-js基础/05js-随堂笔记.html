一,反馈
    1,递归(只有函数)
    1)自己调用自己多次(函数内部调用)
    2)需要一个中止条件
二,匿名函数
匿名函数,没有函数名的函数
   1,自执行/自调用(只执行1次)
   2,结构:
  (匿名函数)()
       eg: (function(){...})()
  第一个小括号:保护匿名函数
  第二个小括号:调用/执行
   3,场景
      (1)声明函数:
         结构:
         var 函数名 = function(){...}
      (2)函数作为参数传递
      (3)函数作为返回值
      (4)匿名函数自调用/沙箱
      防止全局变量污染
      结构:
      (function(){
        需要隔离/保护的内容
      }();
      引申: 
      1)  匿名函数自调用必须;结尾,以后代码压缩为一行的时候,不会出现问题
      2) ;放到函数的小括号前面也可以
函数写法拓展:
1)function(参数1,参数2){...}  参数1和参数2必选
2)function(参数1[,参数2]){...}参数1是必选,参数2是可选
总结:除了function 函数名(){...}必须有函数名,有接收函数的名字就可以直接用匿名函数
三,对象
万物皆对象
1,初识
  定义:现实生活中:对象有具体的特征和行为;js中,对象是一个抽象,有属性和方法;
  概念:对象是由多个无序的键值对的集合; 
  无序的,对象分配空间,任意一个空间地址;
  存在的意义:方便管理 多个属性的集合
  结构:
   var 对象名 = {
     属性名1:属性值1,   //键值对  键(key):值(value)   ; 键(key)类似变量名,不能是字符串;值(value)  任意类型5个简单 3个复杂;
     属性名2:属性值2,   //属性值可以是任何数据类型,数字,string,array,boolen,[],{},function(){},
     属性名3:属性值3,   //键值对用,隔开   ;会报错
   }
   分析:
   (1)数组 = []
   (2)对象 = {},前面有 = 的{}, 基本上是对象
  应用场景:
  1)存储不同个人,每个人的用户信息
  2)存储页面元素的信息
2,创建对象
  2,1单独创建-字面量
      (1)创建一个空对象
          结构: var obj = {};
      (2)创建一个有内容的对象(使用较多,快速,简单)
          结构:
           var obj = {键:值,键:值;...};
      引申:
        1)this.键  意思:这个对象的键属性   ==>拿到对应的值  
        2)this 在函数内部才有意义
        3)this 指向,谁调用这个函数,this就指向哪个对象
        4)函数直接调用的
          eg: 
          function text(){
            console.log(this.age)
          }   
          text();    //直接调用,window.text();
  2,2单独创建-构造函数 Object(了解,使用较少)
      (1)创建一个空对象 new创建对象
          var 对象名 = new Objet();
      (2)创建一个有内容的对象
          var 对象名 = new Object({键:值,键:值})
  2,3批量创建-工厂函数
     (1)创建一个函数
     (2)在函数内创建一个空对象
     (3)给空对象添加属性/方法
     (4)返回出去
     结构:
        function 工厂函数名(形参1,形参2,...){
          var 对象名 = {};
          对象名.属性名1 = 形参1;
          对象名.属性名2 = 形参2;
          对象名.属性名3 = function(){
            ...
          }
          return 对象名;
        }
        var 变量名 = 工厂函数名(实参1,实参2,...); //这个变量名接收到的就是工厂函数中创建的对象;
        变量名.属性名3();可以调用此对象中的属性名3那个函数
    优点:可以创建多个对象
    缺点:无法知道具体类型
  2,4批量创建-自定义构造函数(记忆,重要)
      1)函数名字名称,首字母大写(规范,小写的试过也可以,最好用大写)
      2)配合new使用
      结构: 
      function 自定义函数名(形参1,形参2){
        this.属性名 = 属性值;
        this.属性名 = 属性值;
        this,属性名 = function(){
          函数体;
        }
      }
      var 变量名 = new 函数名(实参1,实参2,...);
     3)new的意义
         (1)创建了一个新对象
         (2)this就指向这个新对象(给新对象添加属性)
         (3)执行构造函数(给新对象添加属性值和方法/赋值),实例化
         (4)返回这个新对象给 ( new 函数名(实参1,实参2,...) )
     4)构造函数的作用:添加属性和方法,实例化;
     优点:可以用constructor查看具体类型,出来的类型是自定义函数名的对象
3,设置/操作对象的属性
  3,1定义:将对象中的属性调出来使用
  3,2结构:对象名.键名
     1)赋值
      结构:对象名.属性名 = 值;
      赋值的属性存在即修改;属性不存在则为添加;
     eg: obj.name = '小马哥';
     2)取值
     结构:对象名.属性名
     属性存在,直接拿到属性值;属性不存在undefind
    3)删除(少用,慎用)
    结构:delete 对象名.属性名
四,查看数据类型
  简单数据类型: number string boolean undefind null
  复杂数据类型: function array object 
  查看数据类型方法:
    1, typeof
      (1)只能查看简单数据类型(不包括null)
      (2)复杂数据类型都是object,分不清
      (3)function查看结果是函数
    2, instanceof
      结构: 对象 instanceof 构造函数  =>查看是否为true
      eg: num6 instanceof Array
        (1)判断,返回一个boolean值,true/false;
    3,constructor 构造器  直接获取
      结构:console.log(检测变量名.constructor.name);
五,    .语法和[]语法
    1,  .语法   获取到属性值
       结构: 对象名.属性名(类似于变量的,不是字符串)；属性名必须和对象中的属性名一一对应;
       注意:     .语法后面只能跟着属性名
    2,  []语法   '属性名字符串'    获取到属性值
        结构:对象名['属性名字符串']
        注意:  []内可以写字符串,数字,变量
    应用场景:遍历对象
        结构: for(var 变量名 in 对象名){  //变量名代表属性名  "var 变量名 in 对象名"  这句话默认给  变量名 赋值了一个字符串属性
            获取到属性名:   变量名   得到的是    字符串格式;
            获取到属性值:   对象名[变量名];
            不能是    对象.变量名    在for in变量对象的时候,默认  变量名 是属性名,所以对象内没有这个属性,会返回undefind
      }
    3,引申:
        判断这个属性是否是对象里的属性
        if('变量名' in 对象名){
          执行代码;
        }else{
          执行代码;
        }
    4,获取对象里的所有属性
    结构: Object.keys(对象名)
       返回的是一个数组  属性名字符串
六,值类型,引用数据类型
1,值类型:变量在存储简单类型的时候,存的是值本身
2,引用/地址类型:变量在存储复杂数据类型的时候,存的是引用/地址
   复杂数据类型 => 里面有个空间 =>存储的是地址


七,声明变量:
var     es5
let const  es6
let  变量
const  常量(一旦赋值了,后面不能再修改了)

