一,函数
    正常的重复代码,代码重复,代码冗余,不方便统一设置修改
    意义:把需要重复的代码封装起来,可以在任意的地方使用
    一次声明,多次调用
    使用场景:只要有js的地方,都有函数
二,函数的声明与调用
1,声明函数/创建
如果直接打印函数名,会打出整个函数结构和函数体
   1,1法1:
    结构:   function 函数名(){
             函数体/代码块
         }  
     eg:  sayHi(){
       console.log('想打啥打啥');
     }
     注意:
      1)打印函数名,就是这个函数
      2)直接声明的函数,是不会自己执行的,需要调用它,才能执行
      3)函数可以多次调用,函数如果不执行,将毫无意义
   1,2法2:
    结构:
      var 函数名 = function () {}
   1,3法3:js高级用
   结构:
   var fn = Function();
2,调用函数
    结构:
       函数名()
3,函数的参数   给不确定的值  可有可无
     3,1形参(形式参数)  声明时用的
         结构:   function 函数名(形参1,形参2,...){
                    函数体/代码块
                   }  
        1)没有意义,占位置用的

     3,2实参(实际参数)   调用时用的
         结构:   函数名(实参1,实参2,....)
        1)真实值,可以是任意数据类型
        2)最好几个形参对应几个实参
    3,3注意:
        1)调用函数的时候,实参将值传给形参
        2)形参,只能在函数内部使用,不能再外部使用
    3,4总结:
       形参
        1)形参可有可无,如果有实参,形参和实参要一一对应.
        2)形参的命名按照命名规范来,类似变量
        3)形参没有值意义的,纯粹是实参传过来的
        4)形参,只能在当前函数内部使用
        5)如何确定形参?把不确定的值,作为形参
        6)形参可以设置多个
      实参
        1)可以传任意类型
        2)实参传给形参,传过去的值,形参一一对应接收
        3)多个实参用,隔开
      传参
         调用函数的时候,里面的实参会传值给形参
4,返回值 return
    函数内部不写return,默认是空
    如果之前没有写return的值,直接打印调用的   函数名()   会提示undefind
       结构:  
       return 值/表达式;  会直接将return后面的值传给 函数名(实参1,实参2)
    1)返回值,如果没有return,提示undefind
    2)返回值,如果有return,函数名(实参1,实参2)的值就是return后面的值
    3)return后面的代码不会执行,return会中止函数
    4)return后面只能返回一个值
    5)return后面的值可以是任意类型
eg: 
console.log(sum2(2,5));
sum2(2,5)  ==>作用:
                  1)调用函数,执行函数,传参
                  2)如果有返回值return,那么它的值与return后面的值相等
                  3)如果没有返回值,提示undefind
                  4)它自身有值(即返回值后面的值),所以它可以当做一个值赋值给变量名
引申:
1)break 中止for循环
2)return 中止函数并且返回一个值
3)return 后面的代码是不会执行的


5,函数的三要素
函数名,参数,返回值
    结构:
    function 函数名(形参1,形参2,...){
      //函数体
      return 返回值;   //return一定要放在后面
    }
    //调用
    函数名(实参1,实参2,...)

    
6,函数内部可以调用其他函数
7,递归函数
  定义:在函数内部自己调用自己
  注意:
     1)慎用,耗性能
     2)一定要有个出口/中止条件/结束条件
  eg: 求1-100的和
  function sum(n){
    if(n==1){
      return 1;
    }
    return sum(n-1)+n;
  }
  var res = sum(100);
  console.log(res);
8,函数作为参数
    函数也                                                                                                                                                                                                                                                                                          是一种数据类型,跟其他数据类型一样可以作为参数传递
9,函数也可以作为返回值
    函数和其他类型一样,可以作为返回值

三,断点调试
  左起开始,每个按钮
      1)断点调试,跳到下一个断点
      2)跳过函数,当函数里面没有断点的时候,会跳过函数;若函数内有断点,则变成单步调试
      3)进入函数
      4)跳出函数
      注意:没有断点的时候,2,3,4步是跳过,跳进,跳出;若函数内部有断点,则变为单步调试
      5)单步调试
      6)让断点失效
      7)自动调试(用的较少) 

watch 监听窗口
call stack 调用站  查看当前执行函数的情况,进行中的左边会有个蓝箭头;未执行完的,灰色显示;执行完,或者未开始执行的不显示
     1)anonymous   主函数,一进入代码就有的函数,也叫入口函数




四,函数也是一种类型
1,通过typeof查看
  eg: 
  var fn = function(){...}
  typeof fn => typeof(fn)
2,和其他数据类型一样,也是数据,所以,其他数据类型能做的事,函数也可以


五,作用域
全局作用域和局部作用域
1,全局作用域
    1)在全局起作用的区域叫全局作用域,
    2)在全局作用域声明的变量叫全局变量
    3)全局变量,所有地方都能访问
2,局部作用域
    1)在局部起作用的区域叫局部作用域,
    2)在局部作用域声明的变量叫局部变量
    3)局部变量,只有局部能访问;
    4)如果局部有,优先有局部变量,如果局部没有,再从全局找;
注意:
隐式全局变量,直接赋值没有声明的变量,也是全局变量,全局皆可访问;
不用var声明的,eg:   a = 10;


六,预解析
js代码执行的真正过程(每次开始执行前,先预解析,再一行一行执行代码)
    1,预解析
    2,代码一行一行的执行
    3,把var声明的变量,把声明提升到当前作用域的最前面,但不提升赋值;
    4,函数声明,提升整个函数到当前作用域的最前面;如果函数是通过var声明的,只提升声明(会报错),不提升整个函数;
    5,如果函数同名,后面的会覆盖前者,eg:后渲染的覆盖先渲染的
    6,如果var声明的普通变量,和函数同名,函数优先
引申:
 var a = b = c = 9;
 意思为:var a = 9;
           b = 9;
           c = 9 ; 









