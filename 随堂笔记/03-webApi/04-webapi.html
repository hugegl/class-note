一,复习
1,节点的属性和方法
   1,1类型的属性
        nodeType  返回值:数字    1(标签)
        nodeName  返回值:字符串   大写(标签)
        nodeValue 返回值:null等    标签返回null
   1,2节点层级的属性
    parentNode  父节点
    childNodes  子节点
    children    子元素
    nextElementSibling   下一个兄弟元素
    previousElementSibling  上一个兄弟元素
  1.3节点的属性和方法
  父元素.appendChild(要添加的节点)   往后面添加子节点
  父元素.insertBefore(新,参考)   往参考节点前面添加新的节点
  父元素.replaceChild(新,旧)   新的字节点替换旧的子节点
  父元素.removeChild(要删除的节点)     删除子节点
  父元素.cloneNode(true/false)      true深拷贝,false默认值浅拷贝
2,js动态创建元素
  innerHTML = '内容'   直接赋值一个html形式的字符串,会识别标签,并且直接渲染到页面上
  document.craeteElement('标签名')   只创建元素,并没有添加到dom树上

---------------今日内容-------------------------------------------------------
一,注册事件的其他方式
1,方法一
事件源.on事件名 = 事件处理函数
    缺点:同一个元素只能注册同一个事件
2,方法二
  addEventListener
    优点:可以给同一个元素,多次注册同一个事件
        结构:
           事件源元素.addEventListener('事件名',事件处理函数,参数3);
       注意:
       1)事件名直接写,不加on
       2)事件处理函数可以是匿名函数,也可以有名字的函数在这里调用
       3)参数3  传入一个boolean值,不写的默认值时false;
                如果是true,则事件处理函数在捕获阶段执行;
                如果是false,则在事件冒泡阶段执行,如果这个元素是事件目标,那么true/false无效;
二,移除事件
注意:用什么方式注册的事件,就用什么方式移除事件
1,方法一
    注册事件:  事件源.on事件名 = 事件处理函数
    移除事件:  事件源.on事件名 =null
2,方法二
    函数名:事件处理函数
    注册事件:  事件源元素.addEventListener('事件名',函数名,false)
    移除事件:  事件源元素.removeEventListener('事件名',函数名,false)
    注意:
    1)如果是匿名函数,虽然执行内容一样,但并不是同一个函数,只有给了函数名,
            指向的是同一个事件函数地址,才指的是同一个事件处理函数
    2)如果我们后面要移除事件,那么注册的时候,第二个参数就不要使用匿名函数的方式
三,事件对象
    意义:可以获取事件触发时的信息,如:触发事件时,鼠标的坐标,触发的是谁的事件....,而我们需要的这些信息都存储在事件对象身上
    定义:触发事件的那一刻,浏览器会自动创建一个对象出来,这个对象身上存储了我们需要的信息,这个对象就叫做事件对象
    如何使用:  
    1,如何获取事件对象
如果我们需要使用事件对象的话,只需要在事件处理函数上写一个形参来接收一下即可,因为浏览器会自动把事件对象当做实参,传递进来
    1,1事件对象的常用属性
    备注:event只事件对象,随便起的名字
    1)event.type    事件类型(事件名)
    2)event.target  事件目标,事件源,触发谁的事件,谁就是事件目标
    3)event.clientX       触发事件时,鼠标相对浏览器可视区的水平坐标,浏览器可视区(即用户可见的浏览器的大小,缩小的也是缩小的可视区范围)
    4)event.clientY       触发事件时,鼠标相对浏览器可视区的垂直坐标
    5)event.pageX         触发事件时,鼠标相对页面的水平坐标,页面,就是一整个网页
    6)event.pageY         触发事件时,鼠标相对页面的垂直坐标
    7)keyCode             键盘按键对应的数字(对应ASCII码,兼容性较好)
        key    返回值:按下的键
        code   返回值:keyR   R指按下了k键,就是按下的那个键的大写
四,事件流
1,定义:
        1)只要点击/鼠标移入...发生了,就一定触发了事件,跟我们有没有注册没有关系
        2)一旦触发了事件,就会产生一个事件流
        3)然后马上要确定下来一个事件路径
2,事件路径方向
定义:假如点击了box,那么事件路径就是:window  -->  document  -->  body  --> box
    2,1事件路径的三个阶段
    捕获阶段:从window往里找目标的过程
    目标阶段:到达目标了
    冒泡阶段:从目标离开,往外找window的过程
3,利用冒泡现象进行事件委托
定义:本来是自己做的事情,委托给父级元素(不一定是亲父级)
优点:代码简洁,节省内存
原理:事件流(事件冒泡)
    eg:事件委托案例
    结构:   ul.onclick = function(e){ //e形参,返回的是事件对象   ul是父级,触发下面的自己
        e.target //当前点的是哪个,target就只哪个
    }

    注意:
    1)如果目标没有注册此事件,但是父级注册了,事件一旦触发,冒泡影响即开始
4,事件对象的两个方法
1)阻止事件传播(冒泡影响)
写的地方,即执行完代码之后的父级阻止传播
书写结构:
        event.stopPropagation()   //event形参,由function的形参传入
2)阻止默认行为
注意:用addEventListener注册的事件中不能使用return false来阻止a链接的默认行为
书写结构:
        event.preventDefault()   //event形参,由function的形参传入









练习引申:
1)如果给整个页面注册事件,那么事件源就是document,不能写body,因为整个body很大
2)鼠标移动事件:mousemove
3)几个键盘事件:
    keydown     键盘按下时触发(常用),不区分大小写,返回的都是大写的ASCII码
    keyup       抬起时触发
    keypress    键盘按下时触发(区分大小写)
4)把ASCII码转换成对应的字符
   结构:   String.fromCharCode(直接写ASCII码)
5)使元素获取焦点的方法
    结构: 元素.focus()
    作用:使元素获得焦点
6)用if语句判断,其实就是判断true和false,如果要判断结果==true的话,在判断句里就直接写,不用写==true
7)对象(函数,数组,对象)转boolean都是true
8) addEventListener在ie8中不支持,
可用attachEvent('on事件名',事件处理函数),可用return false来阻止a链接的默认行为
  移除:detachEvent('on事件名',事件处理函数)
9)兼容写法:   e =  e || window.event; //如果e为true,即能支持,就把e赋值给e,如果e为false(ie8不支持),则返回window.event(转换成boolean为true)赋值给e
10)比较运算符:
    值1 || 值2    先从第一个开始看,如果值1为true则返回值1,否则看值2
    值1 && 值2    先看值1,如果是true,则看第二个,如果也是
11)pageX和pageY在ie8不能用
12)target在ie8不能用
13)如果想用复杂伪数组和普通数据拼接,不能使用   元素.children 去拼接,
    这样返回的是伪数组,是复杂数据类型,不能和字符串拼接,效果无法渲染
    可以使用    元素.innerHTML获取到标签和内容,即字符串去和新的拼接