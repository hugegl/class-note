一,浏览器渲染机制
        1)解析html结构,生成dom树(只有节点,无css样式)
        2)解析css样式,得到样式结构体(去掉浏览器不能识别的样式)
        3)构建渲染树(Render Tree呈现树)   html结构+css样式  ;不包含隐藏的元素
        4)布局渲染树;回流发生的阶段
        5)绘制渲染树;重绘发生的阶段
二,回流  和 重绘
    1,回流(reflow):又译为重排;页面中的元素发生了影响布局的变化;如改变宽高,尺寸,修改显示隐藏状态;
          页面需要重新布局,就会触发回流
    2,重绘(repaint):页面中的元素发生不影响布局的样式变化;如背景图片,字体颜色等;
            页面需要重新渲染,就会触发重绘
    要点:   1)每个页面至少进行一次回流和重绘;
            2)回流必将引起重绘;
三,浏览器维护队列
    当js代码中需要修改页面中的css时,浏览器会维护一个队列,并不会立即进行渲染操作;
    将所有css样式操作,放到队列中,等js执行完,一次性进行渲染;
        1,js执行主线程和UI渲染进程是互斥的(同时只能执行一个);
        2,特例,对于一些获取性操作,为了保证获取数值的准确性,会提前flush(清空)浏览器维护的队列,将其解析渲染;
四,如何性能优化
    1,减少回流和重绘的次数就需要简单的对渲染的操作;
          1)直接使用class类名来修改大量样式;
          2)让操作的元素进行离线处理,display:none;处理完成之后再重新布局和渲染;只引发2次回流和重绘;
          3)将需要多次回流的元素,position:absolute或者fixed,这样此元素就脱离了文档流,它的变化不会影响整体布局;
    总结--注意点:
    1,尽量不要在for循环中进行样式获取性操作;
    2,通过添加class来进行一次性修改样式,少用style;
    3,将需要大量进行回流操作的元素进行display:none;离线处理;
    4,定位(absolute和fixed)的元素,脱标了,不会影响到其他盒子的布局;
    5,使用translate代替left/top等,translate只触发了重绘,不会触发回流;可以节约一次回流的时间;
    6,可以通过opacity替换visibility,改透明度;改透明度渲染效率更高;






引申:
1,获取元素里面的所有样式
window.getComputedStyle(元素);获取元素渲染之后的样式
window.getComputedStyle(元素).backgroundColor;返回元素的背景颜色;
2,浏览器的工具有 Performance,能记录页面中变化的所有过程,每个都截屏下来了;
    update layer tree ;修改渲染树;
3,雅虎性能优化,35条黄金定律;官网搜索;




