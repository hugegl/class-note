一,解决不同移动端屏幕大小不统一的问题
	结合以下两点,就能达到适配的目的
	1,流式布局:百分比自适应布局;
	2,需要对移动端的viewport视口进行设置;
二,流式布局
	其实就是百分比布局,非固定像素,向两侧填充,理解成流动的布局,成为流式布局;
三,	视觉窗口
	视口:viewport；
	是移动端特有的,这是一个虚拟的区域,承载网页的;
	他们的关系:浏览器承载viewport承载网页;
四,浏览器的手机模拟窗口各参数的意思
	screen:屏幕大小
	2:像素大小
	zoom to fit:缩放尺寸,是模拟器的;
五,适配方案
	1,网页内容的宽度必须和浏览器保持一致
	2,默认显示的缩放比例和pc端保持一致(缩放比例1:1);
	3,不允许用户自行缩放网页;
	满足这些要求,达到了适配国际上通用的适配方案,标准的移动端适配方案;
六,viewport适配设置
	如果任何设置都没有,默认走的就是viewport的默认设置
	去设置新的viewport设置,达到适配要求;
	1,<meta name="viewport">设置视口的标签 在head里面并且应该紧接着编码设置
		设置宽度				width     当前设备的宽度:device-width
		设置高度				height     当前设备的高度:device-height
		设置默认的缩放比例		initial-scale
		设置是否允许用户自行缩放 user-scalable
		设置最大缩放比例		maximum-scale
		设置最小缩放比例		minimum-scale
	2,<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">;标准适配参数//content使用以上参数;
		1)width=device-width  宽度比例是1.0
		2)initial-scale=1.0   宽度比例是1,0
		3)user-scalable=no   不允许用户自行缩放(参数,yes,no,0???1)
	3,快捷方式   meta:vp +tab键;
七,非主流适配方案
	1,页面的真实尺寸会比设备的上尺寸要大几倍
	2,假设设备是iPhone4->320px->网页尺寸640px;px是css单位,真机分辨率不是px;移动端尺寸计算都是从边框开始的;
	3,缩放操作,有2倍的,有3倍  和屏幕像素比有关系
	4,什么是屏幕像素(物理像素)px(页面的尺寸单位);移动设备有物理像素的概念,1px里面可能放多个物理像素;
	5,物理像素是设备显示屏的最小可是颗粒的大小  以前的手机(直板手机)的颗粒度
	6,现在有高清显示屏,视网膜屏  retina屏;
	7,显示的效果就提高了 更细腻  但是在显示同等质量的图片的时候(模糊效果)
	8,在屏幕像素比(一个px宽的屏幕能放几个物理像素)高的设备  图片(非矢量)显示会模糊
	9,提高网页的清晰度  根据屏幕的像素比  来缩放网页
	10,但是这样的适配方案成本非常高
	11,一般的企业开发当中使用的还是标准化设置
	13,但是标准化设置,在高清显示屏当中,图片可能会失真(模糊)
八,移动端js
	1,可以使用jQuery,但是不建议
	2,jQuery 做了很多桌面浏览器的兼容问题,特别是IE,但是移动端没有IE浏览器
	3,主流的浏览器:谷歌 火狐(2016年停止了维护和更新) safai浏览器 百度  360  qq
	4,特点:内核基本上都是 webkit 或者 blink  兼容 -webkit-
	5,建议使用H5的api  或者使用一个叫做:zepto.js  的库(基于高版本的浏览器开发)
九,移动端布局
	1,以流式布局为主
	2,百分比布局
	3,非股东像素布局
	4,无法准确计算容器的尺寸

案例知识点
1,盒子变成内减模型
	box-sizing:border-box;
	-webkit-box-sizing:border-box;
	移动端常用布局为非固定式布局,所以无法确定盒子大小,用border-box有效防止内容溢出;
2,点击高亮效果清除
	tap-highlight-color:transparent;
	-webkit-tap-highlight-color:transparent;
3,字体
	font-family:'Microsoft Yahei',sans-serif;
4, input  
	border:none;
	outline:none;
	resize:none;//不允许改变尺寸;
	-webkit-appearance:none;//元素的外观 没有任何样式;
5,百分比计算是针对父容器的内容进行计算的;
6,背景图片压缩连写:
	background:url('路径') x y /w h;//xy是压缩后精灵图的位置,wh是压缩后精灵图的宽高;
7,图片默认是inline-block;解决基线对齐时留白问题
	1)给父元素设置:font-size:0px;//父元素文字大小为0;
	2)img{display:block;};//转成块级
	3)img{vertical-algin:middle;};//让图片的对齐方式居中
-------------------------------------------------------------------第二天--------------------------------------
一,touch事件
	1,touch
	是移动端的触摸事件,是一组事件;利用touch相关事件可以实现移动端常见滑动效果和移动端常见的手势事件
		1)touchstart  当手指触摸屏幕的时候触发
		2)touchmove		当手指在屏幕中来回滑动的时候触发
		3)touchend		当手指离开屏幕的时候触发
		4)touchcancel	当被迫终止滑动的时候触发(来电,弹消息)
	2,绑定事件
		addEventListener('事件名',事件处理函数)
	3,事件对象 - touchEvent事件对象
	触摸点的集合touchList;一个手指触摸就是一个触发点,和屏幕的接触点的个数
		需要关注的三个属性
		1)changedTouches    改变后的触摸点集合;每个事件都会记录
		2)targrtTouches		当前元素的触摸点集合;离开屏幕的时候无法记录
		3)touches			页面上所有触摸点集合;离开屏幕的时候无法记录
	4,事件对象.touches[0]  拿到触摸点中记录当前触摸点的坐标,第一个触摸点
		1)clientX/Y  基于浏览器的坐标
		2)pageX/Y  基于页面的坐标
		3)screenX/Y  基于屏幕的坐标
	5,移动端的手势事件,封装好的方法,掌握原理
		swipe  swipeleft  swiperight  swipetop  swipebottom
	左滑右滑手势怎么实现
二,tap事件
移动端也有click事件,为了区分滑动还是点击,click点击延时,300ms;
响应太慢,用户体验差;解决方案:
1)tap事件;/非移动端原生事件,通过touch相关事件衍生过来的;zepto.js  tap事件  了解原理;
2)使用一个叫:fastclick.js 提高移动端响应速度的;引包后,使用DOM元素加载完成后,正常使用click事件即可;
	1,tap 轻击 轻触(响应速度快);
		1)响应速度比click块 150ms;
		2)不能滑动;
三,实现区域滚动的效果
iscroll.js插件;子容器大于父容器;具体使用查api;
	new IScroll(实现滚动的大容器,{
	scrollX:false,
	scrollY:true,
	})

案例及引申
1,Date.mow();获取当前时间戳;
2,DOMContentLoaded;DOM元素加载完成后会触发的事件;
3,让背景从盒子的内容开始平铺;bagkground-origin:content-box;
4,背景裁减;bagkground-clip:border-box;//默认从边框以外被裁减;padding-box;//填充以外被裁减;content-box;//内容以外被裁减;
5,overflow:hidden;让这个元素绝对绝缘,形成bfc区域;不让其他元素影响自己,而且不让自己浮动的元素去影响别人;
6,张鑫旭BFC;关于bfc的文章;
-----------------------------------------------------------第三天-------------------------------------------
一,响应式布局
	1,原理:css3中的media Query(媒体查询);通过查询screen的宽度,来指定某个宽度区间的网页布局;
	2,超小屏幕(移动设备) 768px以下
	3,小屏幕		 		768px~992px   版心750px
	4,中等屏幕			992px~1200px   版心970px
	5,宽屏设备			1200px以上   版心1170px
二,媒体查询媒体查询
	使用媒体查询能正对不同屏幕设置不同的布局和样式
	1,媒体查询
	结构:@media  screen and (条件) and (条件)....{执行代码};//使用媒体查询
	2,媒体查询的另一种写法
	@media(条件1){执行代码};
	@media(条件2){执行代码};
	@media(条件3){执行代码};
	@media(条件4){执行代码};
	注意: 屏幕尺寸的大小排列:   	条件1<条件2<条件3<条件4 ; 利用的是代码执行的时候会覆盖,但是注意一定按照屏幕从小到大排列;
三,	bootstrap框架
当下最流行的前端UI框架(有预制界面组件)
是一个HTML,CSS,JS框架;
	1,优点:
		1)有自己的生态圈,不断的更新迭代
		2)提供了一套简洁,直观,强悍的组件
		3)标准化的html+css编码规范
		4)让开发更简单,提高了开发效率
	注意:虽然界面组件样式已经定义好了,但是扩展性相对较强,可以自定义,修改默认样式
	2,版本:
		2.XXX 停止维护;兼容性好;代码不够简洁,功能不够完善;
		3.XXX 目前使用最多,稳定,放弃了IE6-7,对IE8支持但是界面效果不好;
				偏向于开发响应式布局,移动设备优先的web项目;
		4.XXX  测试阶段 更偏响应式,移动设备;
	3,基本模板(看懂每一句什么意思),笔记中有注释,或者看官方起步文档
		1) meta的三个标签必须放在最前面;优先加载和浏览器解释;
		2)引入bootstrap的核心样式文件;
			'路径'bootstrap/css/bootstrap.min.css;
		3)html5shiv和respond分别用来解决IE8版本浏览器不支持H5标签化额媒体查询的不兼容问题
		4)  respond不支持file协议打开,本地打开;最好以htpp://打开;
		5)bootstrap框架依赖于jquery;
		6)bootstrap 核心的js文件
	4,normalize.css和自己reset的区别
		同:都是重置样式库,增强浏览器的表现一致性
		异:rset.css  list-style:none  因为需求需要增加自己的样式;
			normallize.css 不会重置ul样式 本身已经在每个浏览器表现一致的元素;
四,基本样式  用类名控制
	1,布局容器
		.container容器
			Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。
			默认带了15px左右的padding值
		.container-fluid
			类用于 100% 宽度，占据全部视口（viewport）的容器。
		注意:这两种容器不能互相嵌套
	2,栅格系统
		定义:行和列的布局方式,又称网格系统;
		行:   .row 由内容撑开;嵌套在container容器内;
			填充父容器的15px的左右内间距 margin-left,margin-right设置-15px的间距,拉伸;
		列:  col-*-*;//*不确定,可以放任意自定义的值;默认两侧有15px的内边距;屏幕宽度小于设置宽度,自动换行;
			col-屏幕大小-每一行的等分;col列样式		
			屏幕大小参数: 
				大屏设备 lg  大屏设备以上生效包含本身;
				中屏设备 md  中屏设备以上生效包含本身;
				小屏设备 sm  小屏设备以上生效包含本身;
				超小屏设备 xs  超小屏设备以上生效包含本身;
			每一行的等分:默认分成12份,数字代表占多少分
	3,栅格系统应用场景:
		1)响应式栅格系统:根据屏幕大小使用栅格系统;
		2)栅格的嵌套:行列可以随意嵌套;可以在任何地方使用,里面百分比的划分是根据父容器来的;
		3)列偏移:
			偏移几等分:col-屏幕大小-offset-几等分
		4)列排序:
			col-屏幕大小-push-几等分;//推,往后推
			col-屏幕大小-pull-几等分;//拉,往前拉
	4,响应式工具:
		结构:  
		visible-lg   大屏显示,其他隐藏;
		visible-md   中屏显示,其他隐藏;
		visible-sm   小屏显示,其他隐藏;
		visible-xs   超小屏显示,其他隐藏;
			3.2版本以后  建议使用hidden;
		hidden-lg    大屏隐藏,其他显示;
		hidden-md    中屏隐藏,其他显示;
		hidden-sm    小屏隐藏,其他显示;
		hidden-xs    超小屏隐藏,其他显示;
五,微金所案例

引申:
1,awesomes前端开发插件/库/框架等等的总网站;
2,LESS和SASS;后期讲;功能一样,语法不一样;bootstrap用的less,也支持sass;
3,路径导航,面包屑导航;
4,自己自定义图标
	1)@font-face定义自己的字体图标
		@font-face{
		font-family:'自定义名字';//申明自己的字体名称;
		url(路径)format();//引入字体文件(约束某一段字符代表什么图案)
		};
	2)使用字体
		.自定义名字_icon{
		font-family:自定义名字;
		}
		.自定义名字_icon_类型::before{
			content:'内容';//什么内容代表什么类型,一一对应;base64若干个字符串转与图片相互转换保存的;
		}
		-----------------------------------------------------------第四天-------------------------------------------
一,bootstrap框架
使用:先分析结构,把结构修改成我们需要的样式;
几处类名详解:
		1,折叠按钮显示;需要配合bootstrap框架的核心js文件实现切换效果;
			data-toggle='collapse';申明是什么组件
			data-target='.box';//控制的目标元素,传的是选择器;如果是a元素,可以使用href传入目标元素;
		2,aria-expanded='false';
			aria-*;//代表提供给屏幕阅读器使用的(盲人阅读器)
		3,sr-only;//screen read only;代表提供给屏幕阅读器使用的(盲人阅读器)
		4,拷贝源码的模块样式:准确定位到所有元素的选择器并且能保证优先级比源码高;
			针对功能进行覆盖:更改模块名称;
			但是有一些没有用的选择器,代码冗余;
			保留:利于维护,方便产品更新的时候不用再去修改代码;
二,微金所案例
		1,如果不满足需求,需要自己使用媒体查询;
------------------------------------------------------第五天----------------------------------------------------------
一,less的使用(补充,0505期已讲过)
		1,@charset '字符集名称';字符集UTF-8;在定义变量之前先申明字符集名称;
		2,变量,不能以数字开头,不能包含特殊字符,区分大小写;
		3,字符拼接:    
				@className:box;  
				.@{className}{.....}//最后解析成:   .box{.....}'
		4,less.watch();无刷新预览样式
二,	bootstrap框架
		affix模块:  固定,可以用来做导航固定;



三,引申 
				1,jQ方法:  			each(function(i,v){....});遍历jQ对象;
				2,html标签:    	<sub>内容</sub>;
				3, css 						box-shaddow:参数;    参数inset是内阴影;
				4,h5C3新选择器:				E:first-of-type  先找元素E的父级;通过父元素找子元素当中类型为E的元素,然后再去找第几个;
															E:last-of-type  
															E:nth-of-type()  
															E:nth-last-of-type()  
															E:first-child       先找E的父级;通过父级找到所有子元素,判断第几个子元素是否是E;
				5,字体图标库,插件  font awesome;
-----------------------------------------------------------第六天--------------------------------------------------------------
一,zepto     使用详细参考官方api;大致与jQ一样
		1,定义:是一个轻量的jS库,类似jQ库;体积小,5-10k;jQuery是80-90k;
		2,如果$变量尚未定义,zepot只设置全局变量$指向它本身.没有zepto.noConflict方法;
		3,适配:安卓2.0+;IE10+支持;
		4,带min的包含这五个核心模块:
									zepto;核心模块,包含很多方法;
									event;通过on()&off()处理事件;
									ajax;XML HttpRequest和JSONP实用功能;
									form;序列化&提交web表单
									ie;支持桌面IE10+和Windows phone 8(以前用java ee和java se);
		5,封装好的事件,需要单独引zepto插件touch模块; 安卓4.0可能有兼容问题
		swipe/swipeTop/swipeDown/swipeLeft/swipeRight    滑动/上/下/左/右滑动的事件;
		tap/doubleTap/singleTap/longTap                  轻触/双击/单击/长按事件;
		6,zepto是分模块的,需要某个功能,就需要引入某个zepto的文件;
二,Swiper插件
引用带jQ的轻量小版本,就是依赖jQ的;
		1,常用参数:
		new Swiper('大容器',{   //大容器写选择器能选择到大容器即可
			autoplay:时间, //是否自动播放/毫秒;
			loop:true,  //是否无缝轮播
			pagination:'小圆点的容器',     //是否有小圆点效果,传入小圆点的容器,语法是选择器
			autoplayDisableOnTnteraction:false,   //默认用户滑动后停止自动播放,如果要开启定时播放就传false;
		})
三,rem 
	em:大小时基于父元素的字体大小;
	rem:大小时基于root(根)元素,即html;浏览器默认的字体大小是16px;
四,移动端的常用布局方式
		1,伸缩式布局  flex
		2,流式布局    百分比布局
		3,响应式布局		媒体查询(超小屏设备的时候:流式布局)
		以上三个共同点:只能做宽度的适配(排除图片)
		4,rem布局
			通过控制html上的字体大小去控制页面上所有以rem为单位的基准值控制尺寸
			1)把页面上px单位转换成rem单位
			2)页面制作的时候psd上的量取px转成rem使用
			3)怎么换算?预设一个基准值,方便计算
			4)适配的时候设置基准值
			5)换算公式:当前rem基准值 = 预设的基准值/设计稿宽度*当前设备的宽度
			6)怎么去改变,(js换算/媒体查询);设置的时候,尽量由大到小排列;
			假设设备是:320px或者640px;预设基准值100px =1rem ;设计稿宽度  640px;
				eg:  
					@media (min-width:320px){
						html{font-size:50px}    //换算:  (100/640*320)px = 50px;
					}
					@media (min-width:640px){
						html{font-size:100px}
					}
			rem适配方案不好维护的原因:  设备更新  设计稿尺寸 预设基准值;影响的因素太多;
			适配主流设备:十几种;
五,rem与less结合做布局;
		1,less中申明一个数组,存放主流设备的尺寸;
		2,使用less中的函数,遍历这个数组(less中没有for),可以使用函数迭代;
				less中拿到数组的长度:   length(数组);
				less中定义数组:       @变量名:值1,值2,值3...;
				less中拿到数组中对应序号的值:  extract(@数组名,num)    ; 从1开始计算,从数组中拿对应的号码的参数;
		eg:    
		.函数名(@index) where(@index > 0){
			//执行代码;


			.函数名(@index-1);  //自己调用自己;实现循环;这个循环默认是倒序的;
				//如果想正过来,需要@index-1,并且从@len(数组的长度个,即最后一个开始调用函数);
		}
		.函数名(@len);第一次开始取最后一个;

引申:
			1,jQ中的方法   .end(),返回上一个jQ对象进行操作; .andSelf(),自己和上一个jQ对象都选中,进行操作;
			函数自己调用自己是迭代???




















